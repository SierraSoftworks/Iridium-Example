// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-bluebird/cfd8d3ac544649768a437b5f707fedbe4a60cd18/bluebird.d.ts
declare module '~iridium~bluebird/bluebird' {
// Type definitions for Bluebird v3.x.x
// Project: http://bluebirdjs.com

class Bluebird<R> implements Bluebird.Thenable<R>, Bluebird.Inspection<R> {
  /**
   * Create a new promise. The passed in function will receive functions `resolve` and `reject` as its arguments which can be called to seal the fate of the created promise.
   */
  constructor(callback: (resolve: (thenableOrResult: R | Bluebird.Thenable<R>) => void, reject: (error: any) => void) => void);

  /**
   * Promises/A+ `.then()`. Returns a new promise chained from this promise. The new promise will be rejected or resolved dedefer on the passed `fulfilledHandler`, `rejectedHandler` and the state of this promise.
   */
  then<U>(onFulfill: (value: R) => U | Bluebird.Thenable<U>, onReject?: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U>;
  then<U>(onFulfill: (value: R) => U | Bluebird.Thenable<U>, onReject?: (error: any) => void | Bluebird.Thenable<void>): Bluebird<U>;

  /**
   * This is a catch-all exception handler, shortcut for calling `.then(null, handler)` on this promise. Any exception happening in a `.then`-chain will propagate to nearest `.catch` handler.
   *
   * Alias `.caught();` for compatibility with earlier ECMAScript version.
   */
  catch(onReject?: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(onReject?: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;

  /**
   * This extends `.catch` to work more like catch-clauses in languages like Java or C#. Instead of manually checking `instanceof` or `.name === "SomeError"`, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.
   *
   * This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.
   *
   * Alias `.caught();` for compatibility with earlier ECMAScript version.
   */
  catch(predicate: (error: any) => boolean, onReject: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(predicate: (error: any) => boolean, onReject: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;
  catch(ErrorClass: Function, onReject: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(ErrorClass: Function, onReject: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;

  /**
   * Like `.catch` but instead of catching all types of exceptions, it only catches those that don't originate from thrown errors but rather from explicit rejections.
   */
  error<U>(onReject: (reason: any) => Bluebird.Thenable<U>): Bluebird<U>;
  error<U>(onReject: (reason: any) => U): Bluebird<U>;

  /**
   * Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for `.finally()` in that the final value cannot be modified from the handler.
   *
   * Alias `.lastly();` for compatibility with earlier ECMAScript version.
   */
  finally<U>(handler: () => Bluebird.Thenable<U>): Bluebird<R>;
  finally<U>(handler: () => U): Bluebird<R>;

  lastly<U>(handler: () => Bluebird.Thenable<U>): Bluebird<R>;
  lastly<U>(handler: () => U): Bluebird<R>;

  /**
   * Create a promise that follows this promise, but is bound to the given `thisArg` value. A bound promise will call its handlers with the bound value set to `this`. Additionally promises derived from a bound promise will also be bound promises with the same `thisArg` binding as the original promise.
   */
  bind(thisArg: any): Bluebird<R>;

  /**
   * Like `.then()`, but any unhandled rejection that ends up here will be thrown as an error.
   */
  done<U>(onFulfilled: (value: R) => Bluebird.Thenable<U>, onRejected: (error: any) => Bluebird.Thenable<U>): void;
  done<U>(onFulfilled: (value: R) => Bluebird.Thenable<U>, onRejected?: (error: any) => U): void;
  done<U>(onFulfilled: (value: R) => U, onRejected: (error: any) => Bluebird.Thenable<U>): void;
  done<U>(onFulfilled?: (value: R) => U, onRejected?: (error: any) => U): void;

  /**
   * Like `.finally()`, but not called for rejections.
   */
  tap<U>(onFulFill: (value: R) => Bluebird.Thenable<U>): Bluebird<R>;
  tap<U>(onFulfill: (value: R) => U): Bluebird<R>;

  /**
   * Same as calling `Promise.delay(ms, this)`.
   */
  delay(ms: number): Bluebird<R>;

  /**
   * Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason.
   *  However, if this promise is not fulfilled or rejected within ms milliseconds, the returned promise
   *  is rejected with a TimeoutError or the error as the reason.
   *
   * You may specify a custom error message with the `message` parameter.
   */
  timeout(ms: number, message?: string | Error): Bluebird<R>;

  /**
   * Register a node-style callback on this promise. When this promise is is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be `null` in case of success.
   * If the `callback` argument is not a function, this method does not do anything.
   */
  nodeify(callback: (err: any, value?: R) => void, options?: Bluebird.SpreadOption): this;
  nodeify(...sink: any[]): this;
  asCallback(callback: (err: any, value?: R) => void, options?: Bluebird.SpreadOption): this;
  asCallback(...sink: any[]): this;

  /**
   * See if this `promise` has been fulfilled.
   */
  isFulfilled(): boolean;

  /**
   * See if this `promise` has been rejected.
   */
  isRejected(): boolean;

  /**
   * See if this `promise` is still defer.
   */
  isPending(): boolean;

  /**
   * See if this `promise` is resolved -> either fulfilled or rejected.
   */
  isResolved(): boolean;

  /**
   * Get the fulfillment value of the underlying promise. Throws if the promise isn't fulfilled yet.
   *
   * throws `TypeError`
   */
  value(): R;

  /**
   * Get the rejection reason for the underlying promise. Throws if the promise isn't rejected yet.
   *
   * throws `TypeError`
   */
  reason(): any;

  /**
   * Synchronously inspect the state of this `promise`. The `PromiseInspection` will represent the state of the promise as snapshotted at the time of calling `.inspect()`.
   */
  inspect(): Bluebird.Inspection<R>;

  /**
   * This is a convenience method for doing:
   *
   * <code>
   * promise.then(function(obj){
   *     return obj[propertyName].call(obj, arg...);
   * });
   * </code>
   */
  call(propertyName: string, ...args: any[]): Bluebird<any>;

  /**
   * This is a convenience method for doing:
   *
   * <code>
   * promise.then(function(obj){
   *     return obj[propertyName];
   * });
   * </code>
   */
  // TODO: Use something like subtypes (TS roadmap ?) to get the type U automatically.
  get<U>(key: string | number): Bluebird<U>;

  /**
   * Convenience method for:
   *
   * <code>
   * .then(function() {
   *    return value;
   * });
   * </code>
   *
   * in the case where `value` doesn't change its value. That means `value` is bound at the time of calling `.return()`
   *
   * Alias `.thenReturn();` for compatibility with earlier ECMAScript version.
   */
  return(): Bluebird<any>;
  thenReturn(): Bluebird<any>;
  return<U>(value: U): Bluebird<U>;
  thenReturn<U>(value: U): Bluebird<U>;

  /**
   * Convenience method for:
   *
   * <code>
   * .then(function() {
   *    throw reason;
   * });
   * </code>
   * Same limitations apply as with `.return()`.
   *
   * Alias `.thenThrow();` for compatibility with earlier ECMAScript version.
   */
  throw(reason: Error): Bluebird<R>;
  thenThrow(reason: Error): Bluebird<R>;

  /**
   * Convert to String.
   */
  toString(): string;

  /**
   * This is implicitly called by `JSON.stringify` when serializing the object. Returns a serialized representation of the `Promise`.
   */
  toJSON(): Object;

  /**
   * Like calling `.then`, but the fulfillment value or rejection reason is assumed to be an array, which is flattened to the formal parameters of the handlers.
   */
  spread<U, W>(fulfilledHandler: (...values: W[]) => U | Bluebird.Thenable<U>): Bluebird<U>;
  spread<U>(fulfilledHandler: Function): Bluebird<U>;
  spread<U>(fulfilledHandler: Function): Bluebird<U>;

  /**
   * Same as calling `Promise.all(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  all<U>(): Bluebird<U[]>;

  /**
   * Same as calling `Promise.props(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO how to model instance.props()?
  props(): Bluebird<Object>;

  /**
   * Same as calling `Promise.settle(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  settle<U>(): Bluebird<Bluebird.Inspection<U>[]>;

  /**
   * Same as calling `Promise.any(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  any<U>(): Bluebird<U>;

  /**
   * Same as calling `Promise.some(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  some<U>(count: number): Bluebird<U[]>;

  /**
   * Same as calling `Promise.race(thisPromise, count)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  race<U>(): Bluebird<U>;

  /**
   * Same as calling `Bluebird.map(thisPromise, mapper)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  map<Q, U>(mapper: (item: Q, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  map<Q, U>(mapper: (item: Q, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Same as calling `Promise.reduce(thisPromise, Function reducer, initialValue)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  reduce<Q, U>(reducer: (memo: U, item: Q, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  reduce<Q, U>(reducer: (memo: U, item: Q, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  /**
   * Same as calling ``Promise.filter(thisPromise, filterer)``. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  filter<U>(filterer: (item: U, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  filter<U>(filterer: (item: U, index: number, arrayLength: number) => boolean, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Same as calling ``Bluebird.each(thisPromise, iterator)``. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  each<R, U>(iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;

  /**
   * Start the chain of promises with `Promise.try`. Any synchronous exceptions will be turned into rejections on the returned promise.
   *
   * Note about second argument: if it's specifically a true array, its values become respective arguments for the function call. Otherwise it is passed as is as the first argument for the function call.
   *
   * Alias for `attempt();` for compatibility with earlier ECMAScript version.
   */
  static try<R>(fn: () => Bluebird.Thenable<R>): Bluebird<R>;
  static try<R>(fn: () => R): Bluebird<R>;

  static attempt<R>(fn: () => Bluebird.Thenable<R>): Bluebird<R>;
  static attempt<R>(fn: () => R): Bluebird<R>;

  /**
   * Returns a new function that wraps the given function `fn`. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.
   * This method is convenient when a function can sometimes return synchronously or throw synchronously.
   */
  static method(fn: Function): Function;

  /**
   * Create a promise that is resolved with the given `value`. If `value` is a thenable or promise, the returned promise will assume its state.
   */
  static resolve(): Bluebird<void>;
  static resolve<R>(value: Bluebird.Thenable<R>): Bluebird<R>;
  static resolve<R>(value: R): Bluebird<R>;

  /**
   * Create a promise that is rejected with the given `reason`.
   */
  static reject(reason: any): Bluebird<any>;
  static reject<R>(reason: any): Bluebird<R>;

  /**
   * Create a promise with undecided fate and return a `PromiseResolver` to control it. See resolution?: Promise(#promise-resolution).
   */
  static defer<R>(): Bluebird.Resolver<R>;

  /**
   * Cast the given `value` to a trusted promise. If `value` is already a trusted `Promise`, it is returned as is. If `value` is not a thenable, a fulfilled is: Promise returned with `value` as its fulfillment value. If `value` is a thenable (Promise-like object, like those returned by jQuery's `$.ajax`), returns a trusted that: Promise assimilates the state of the thenable.
   */
  static cast<R>(value: Bluebird.Thenable<R>): Bluebird<R>;
  static cast<R>(value: R): Bluebird<R>;

  /**
   * Sugar for `Promise.resolve(undefined).bind(thisArg);`. See `.bind()`.
   */
  static bind(thisArg: any): Bluebird<void>;

  /**
   * See if `value` is a trusted Promise.
   */
  static is(value: any): boolean;

  /**
   * Call this right after the library is loaded to enabled long stack traces. Long stack traces cannot be disabled after being enabled, and cannot be enabled after promises have already been created. Long stack traces imply a substantial performance penalty, around 4-5x for throughput and 0.5x for latency.
   */
  static longStackTraces(): void;

  /**
   * Returns a promise that will be resolved with value (or undefined) after given ms milliseconds.
   * If value is a promise, the delay will start counting down when it is fulfilled and the returned
   *  promise will be fulfilled with the fulfillment value of the value promise.
   */
  static delay<R>(ms: number, value: R | Bluebird.Thenable<R>): Bluebird<R>;
  static delay(ms: number): Bluebird<void>;

  /**
   * Returns a function that will wrap the given `nodeFunction`. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.
   *
   * If the `nodeFunction` calls its callback with multiple success values, the fulfillment value will be an array of them.
   *
   * If you pass a `receiver`, the `nodeFunction` will be called as a method on the `receiver`.
   */
  static promisify<T>(func: (callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): () => Bluebird<T>;
  static promisify<T, A1>(func: (arg1: A1, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1) => Bluebird<T>;
  static promisify<T, A1, A2>(func: (arg1: A1, arg2: A2, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2) => Bluebird<T>;
  static promisify<T, A1, A2, A3>(func: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3) => Bluebird<T>;
  static promisify<T, A1, A2, A3, A4>(func: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Bluebird<T>;
  static promisify<T, A1, A2, A3, A4, A5>(func: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Bluebird<T>;
  static promisify(nodeFunction: Function, options?: Bluebird.PromisifyOptions): Function;

  /**
   * Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name postfixed with `Async`. Returns the input object.
   *
   * Note that the original methods on the object are not overwritten but new methods are created with the `Async`-postfix. For example, if you `promisifyAll()` the node.js `fs` object use `fs.statAsync()` to call the promisified `stat` method.
   */
  // TODO how to model promisifyAll?
  static promisifyAll(target: Object, options?: Bluebird.PromisifyAllOptions): Object;

  /**
   * Returns a promise that is resolved by a node style callback function.
   */
  static fromNode(resolver: (callback: (err: any, result?: any) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<any>;
  static fromNode<T>(resolver: (callback: (err: any, result?: T) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<T>;
  static fromCallback(resolver: (callback: (err: any, result?: any) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<any>;
  static fromCallback<T>(resolver: (callback: (err: any, result?: T) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<T>;

  /**
   * Returns a function that can use `yield` to run asynchronous code synchronously. This feature requires the support of generators which are drafted in the next version of the language. Node version greater than `0.11.2` is required and needs to be executed with the `--harmony-generators` (or `--harmony`) command-line switch.
   */
  // TODO fix coroutine GeneratorFunction
  static coroutine<R>(generatorFunction: Function): Function;

  /**
   * Add `handler` as the handler to call when there is a possibly unhandled rejection. The default handler logs the error stack to stderr or `console.error` in browsers.
   *
   * Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.
   */
  static onPossiblyUnhandledRejection(handler: (reason: any) => any): void;

  /**
   * Given an array, or a promise of an array, which contains promises (or a mix of promises and values) return a promise that is fulfilled when all the items in the array are fulfilled. The promise's fulfillment value is an array with fulfillment values at respective positions to the original array. If any promise in the array rejects, the returned promise is rejected with the rejection reason.
   */
  // TODO enable more overloads
  // array with promises of different types
  static all<T1>(values: [Bluebird.Thenable<T1> | T1]): Bluebird<[T1]>;
  static all<T1, T2>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2]): Bluebird<[T1, T2]>;
  static all<T1, T2, T3>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3]): Bluebird<[T1, T2, T3]>;
  static all<T1, T2, T3, T4>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3, Bluebird.Thenable<T4> | T4]): Bluebird<[T1, T2, T3, T4]>;
  static all<T1, T2, T3, T4, T5>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3, Bluebird.Thenable<T4> | T4, Bluebird.Thenable<T5> | T5]): Bluebird<[T1, T2, T3, T4, T5]>;
  // array with values
  static all<R>(values: ((R | Bluebird.Thenable<R>) | Bluebird.Thenable<(R | Bluebird.Thenable<R>)>)[]): Bluebird<R[]>;

  /**
   * Like ``Promise.all`` but for object properties instead of array items. Returns a promise that is fulfilled when all the properties of the object are fulfilled. The promise's fulfillment value is an object with fulfillment values at respective keys to the original object. If any promise in the object rejects, the returned promise is rejected with the rejection reason.
   *
   * If `object` is a trusted `Promise`, then it will be treated as a promise for object rather than for its properties. All other objects are treated for their properties as is returned by `Object.keys` - the object's own enumerable properties.
   *
   * *The original object is not modified.*
   */
  // TODO verify this is correct
  // trusted promise for object
  static props(object: Bluebird<Object>): Bluebird<Object>;
  // object
  static props(object: Object): Bluebird<Object>;

  /**
   * Given an array, or a promise of an array, which contains promises (or a mix of promises and values) return a promise that is fulfilled when all the items in the array are either fulfilled or rejected. The fulfillment value is an array of ``PromiseInspection`` instances at respective positions in relation to the input array.
   *
   * *original: The array is not modified. The input array sparsity is retained in the resulting array.*
   */
  // promise of array with promises of value
  static settle<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>): Bluebird<Bluebird.Inspection<R>[]>;
  // promise of array with values
  static settle<R>(values: Bluebird.Thenable<R[]>): Bluebird<Bluebird.Inspection<R>[]>;
  // array with promises of value
  static settle<R>(values: Bluebird.Thenable<R>[]): Bluebird<Bluebird.Inspection<R>[]>;
  // array with values
  static settle<R>(values: R[]): Bluebird<Bluebird.Inspection<R>[]>;

  /**
   * Like `Promise.some()`, with 1 as `count`. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.
   */
  // promise of array with promises of value
  static any<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>): Bluebird<R>;
  // promise of array with values
  static any<R>(values: Bluebird.Thenable<R[]>): Bluebird<R>;
  // array with promises of value
  static any<R>(values: Bluebird.Thenable<R>[]): Bluebird<R>;
  // array with values
  static any<R>(values: R[]): Bluebird<R>;

  /**
   * Given an array, or a promise of an array, which contains promises (or a mix of promises and values) return a promise that is fulfilled or rejected as soon as a promise in the array is fulfilled or rejected with the respective rejection reason or fulfillment value.
   *
   * **Note** If you pass empty array or a sparse array with no values, or a promise/thenable for such, it will be forever pending.
   */
  // promise of array with promises of value
  static race<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>): Bluebird<R>;
  // promise of array with values
  static race<R>(values: Bluebird.Thenable<R[]>): Bluebird<R>;
  // array with promises of value
  static race<R>(values: Bluebird.Thenable<R>[]): Bluebird<R>;
  // array with values
  static race<R>(values: R[]): Bluebird<R>;

  /**
   * Initiate a competetive race between multiple promises or values (values will become immediately fulfilled promises). When `count` amount of promises have been fulfilled, the returned promise is fulfilled with an array that contains the fulfillment values of the winners in order of resolution.
   *
   * If too many promises are rejected so that the promise can never become fulfilled, it will be immediately rejected with an array of rejection reasons in the order they were thrown in.
   *
   * *The original array is not modified.*
   */
  // promise of array with promises of value
  static some<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, count: number): Bluebird<R[]>;
  // promise of array with values
  static some<R>(values: Bluebird.Thenable<R[]>, count: number): Bluebird<R[]>;
  // array with promises of value
  static some<R>(values: Bluebird.Thenable<R>[], count: number): Bluebird<R[]>;
  // array with values
  static some<R>(values: R[], count: number): Bluebird<R[]>;

  /**
   * Promise.join(
   *   Promise<any>|any values...,
   *   function handler
   * ) -> Promise
   * For coordinating multiple concurrent discrete promises.
   *
   * Note: In 1.x and 0.x Promise.join used to be a Promise.all that took the values in as arguments instead in an array. This behavior has been deprecated but is still supported partially - when the last argument is an immediate function value the new semantics will apply
   */

  // multiple values and handler
  static join<R, A1>(arg1: A1 | Bluebird.Thenable<A1>, handler: (arg1?: A1) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, handler: (arg1?: A1, arg2?: A2) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, handler: (arg1?: A1, arg2?: A2, arg3?: A3) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3, A4>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, arg4: A4 | Bluebird.Thenable<A4>, handler: (arg1?: A1, arg2?: A2, arg3?: A3, arg4?: A4) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3, A4, A5>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, arg4: A4 | Bluebird.Thenable<A4>, arg5: A5 | Bluebird.Thenable<A5>, handler: (arg1?: A1, arg2?: A2, arg3?: A3, arg4?: A4, arg5?: A5) => R | Bluebird.Thenable<R>): Bluebird<R>;

  // variadic array with promises of value
  static join<R>(...values: Bluebird.Thenable<R>[]): Bluebird<R[]>;
  // variadic array with values
  static join<R>(...values: R[]): Bluebird<R[]>;

  /**
   * Map an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `mapper` function with the signature `(item, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * If the `mapper` function returns promises or thenables, the returned promise will wait for all the mapped results to be resolved as well.
   *
   * *The original array is not modified.*
   */
  // promise of array with promises of value
  static map<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // promise of array with values
  static map<R, U>(values: Bluebird.Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // array with promises of value
  static map<R, U>(values: Bluebird.Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // array with values
  static map<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Reduce an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `reducer` function with the signature `(total, current, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * If the reducer function returns a promise or a thenable, the result for the promise is awaited for before continuing with next iteration.
   *
   * *The original array is not modified. If no `intialValue` is given and the array doesn't contain at least 2 items, the callback will not be called and `undefined` is returned. If `initialValue` is given and the array doesn't have at least 1 item, `initialValue` is returned.*
   */
  // promise of array with promises of value
  static reduce<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // promise of array with values
  static reduce<R, U>(values: Bluebird.Thenable<R[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<R[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // array with promises of value
  static reduce<R, U>(values: Bluebird.Thenable<R>[], reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<R>[], reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // array with values
  static reduce<R, U>(values: R[], reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: R[], reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  /**
   * Filter an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `filterer` function with the signature `(item, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * The return values from the filtered functions are coerced to booleans, with the exception of promises and thenables which are awaited for their eventual result.
   *
   * *The original array is not modified.
   */
  // promise of array with promises of value
  static filter<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // promise of array with values
  static filter<R>(values: Bluebird.Thenable<R[]>, filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<R[]>, filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // array with promises of value
  static filter<R>(values: Bluebird.Thenable<R>[], filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<R>[], filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // array with values
  static filter<R>(values: R[], filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: R[], filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  /**
   * Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given iterator function with the signature (item, index, value) where item is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, the result for the promise is awaited for before continuing with next iteration.
   */
  // promise of array with promises of value
  static each<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;
  // array with promises of value
  static each<R, U>(values: Bluebird.Thenable<R>[], iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;
  // array with values OR promise of array with values
  static each<R, U>(values: R[] | Bluebird.Thenable<R[]>, iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;

  /**
   * A meta method used to specify the disposer method that cleans up a resource when using `Promise.using`.
   *
   * Returns a Disposer object which encapsulates both the resource as well as the method to clean it up.
   *  The user can pass this object to `Promise.using` to get access to the resource when it becomes available,
   *  as well as to ensure its automatically cleaned up.
   *
   * The second argument passed to a disposer is the result promise of the using block, which you can
   *  inspect synchronously.
   */
  disposer(disposeFn: (arg: R, promise: Bluebird<R>) => void | Bluebird.Thenable<void>): Bluebird.Disposer<R>;

  /**
   * In conjunction with `.disposer`, using will make sure that no matter what, the specified disposer
   *  will be called when the promise returned by the callback passed to using has settled. The disposer is
   *  necessary because there is no standard interface in node for disposing resources.
   */
  static using<R, T>(disposer: Bluebird.Disposer<R>, executor: (transaction: R) => Bluebird.Thenable<T>): Bluebird<T>;
  static using<R1, R2, T>(disposer: Bluebird.Disposer<R1>, disposer2: Bluebird.Disposer<R2>, executor: (transaction1: R1, transaction2: R2) => Bluebird.Thenable<T>): Bluebird<T>;
  static using<R1, R2, R3, T>(disposer: Bluebird.Disposer<R1>, disposer2: Bluebird.Disposer<R2>, disposer3: Bluebird.Disposer<R3>, executor: (transaction1: R1, transaction2: R2, transaction3: R3) => Bluebird.Thenable<T>): Bluebird<T>;

  /**
   * Add handler as the handler to call when there is a possibly unhandled rejection.
   * The default handler logs the error stack to stderr or console.error in browsers.
   *
   * Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.
   *
   * Note: this hook is specific to the bluebird instance its called on, application developers should use global rejection events.
   */
  static onPossiblyUnhandledRejection(handler?: (error: Error, promise: Bluebird<any>) => void): void;

  /**
   * Configure long stack traces, warnings, monitoring and cancellation.
   * Note that even though false is the default here, a development environment might be detected which automatically
   *  enables long stack traces and warnings.
   */
  static config(options: {
    /** Enable warnings */
    warnings?: boolean | {
      /** Enables all warnings except forgotten return statements. */
      wForgottenReturn: boolean;
    };
    /** Enable long stack traces */
    longStackTraces?: boolean;
    /** Enable cancellation */
    cancellation?: boolean;
    /** Enable monitoring */
    monitoring?: boolean;
  }): void;
}

namespace Bluebird {
  export interface ConcurrencyOption {
    concurrency: number;
  }
  export interface SpreadOption {
    spread: boolean;
  }
  export interface FromNodeOptions {
    multiArgs?: boolean;
  }
  export interface PromisifyOptions {
    context?: any;
    multiArgs?: boolean;
  }
  export interface PromisifyAllOptions extends PromisifyOptions {
    suffix?: string;
    filter?: (name: string, func: Function, target?: any, passesDefaultFilter?: boolean) => boolean;
    // The promisifier gets a reference to the original method and should return a function which returns a promise
    promisifier?: (originalMethod: Function) => () => Thenable<any>;
  }

  /**
   * Represents an error is an explicit promise rejection as opposed to a thrown error.
   *  For example, if an error is errbacked by a callback API promisified through undefined or undefined
   *  and is not a typed error, it will be converted to a `OperationalError` which has the original error in
   *  the `.cause` property.
   *
   * `OperationalError`s are caught in `.error` handlers.
   */
  export class OperationalError extends Error { }

  /**
   * Signals that an operation has timed out. Used as a custom cancellation reason in `.timeout`.
   */
  export class TimeoutError extends Error { }

  /**
   * Signals that an operation has been aborted or cancelled. The default reason used by `.cancel`.
   */
  export class CancellationError extends Error {}

  /**
   * A collection of errors. `AggregateError` is an array-like object, with numeric indices and a `.length` property.
   *  It supports all generic array methods such as `.forEach` directly.
   *
   * `AggregateError`s are caught in `.error` handlers, even if the contained errors are not operational.
   *
   * `Promise.some` and `Promise.any` use `AggregateError` as rejection reason when they fail.
   */
  export class AggregateError extends Error {}

  /**
   * returned by `Bluebird.disposer()`.
   */
  export class Disposer<R> {
  }

  export interface Thenable<R> {
    then<U>(onFulfilled: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
    then<U>(onFulfilled: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void | Thenable<void>): Thenable<U>;
  }

  export interface Resolver<R> {
    /**
     * Returns a reference to the controlled promise that can be passed to clients.
     */
    promise: Bluebird<R>;

    /**
     * Resolve the underlying promise with `value` as the resolution value. If `value` is a thenable or a promise, the underlying promise will assume its state.
     */
    resolve(value: R): void;
    resolve(): void;

    /**
     * Reject the underlying promise with `reason` as the rejection reason.
     */
    reject(reason: any): void;

    /**
     * Gives you a callback representation of the `PromiseResolver`. Note that this is not a method but a property. The callback accepts error object in first argument and success values on the 2nd parameter and the rest, I.E. node js conventions.
     *
     * If the the callback is called with multiple success values, the resolver fullfills its promise with an array of the values.
     */
    // TODO specify resolver callback
    callback: (err: any, value: R, ...values: R[]) => void;
  }

  export interface Inspection<R> {
    /**
     * See if the underlying promise was fulfilled at the creation time of this inspection object.
     */
    isFulfilled(): boolean;

    /**
     * See if the underlying promise was rejected at the creation time of this inspection object.
     */
    isRejected(): boolean;

    /**
     * See if the underlying promise was defer at the creation time of this inspection object.
     */
    isPending(): boolean;

    /**
     * Get the fulfillment value of the underlying promise. Throws if the promise wasn't fulfilled at the creation time of this inspection object.
     *
     * throws `TypeError`
     */
    value(): R;

    /**
     * Get the rejection reason for the underlying promise. Throws if the promise wasn't rejected at the creation time of this inspection object.
     *
     * throws `TypeError`
     */
    reason(): any;
  }

  /**
   * Changes how bluebird schedules calls a-synchronously.
   *
   * @param scheduler Should be a function that asynchronously schedules
   *                  the calling of the passed in function
   */
  export function setScheduler(scheduler: (callback: (...args: any[]) => void) => void): void;
}

export = Bluebird;
}
declare module '~iridium~bluebird' {
import main = require('~iridium~bluebird/bluebird');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-es6-promise/fb04188767acfec1defd054fc8024fafa5cd4de7/dist/es6-promise.d.ts
declare module '~iridium~mongodb~es6-promise/dist/es6-promise' {
export interface Thenable <R> {
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;
}

export class Promise <R> implements Thenable <R> {
  /**
   * If you call resolve in the body of the callback passed to the constructor,
   * your promise is fulfilled with result object passed to resolve.
   * If you call reject your promise is rejected with the object passed to resolve.
   * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
   * Any errors thrown in the constructor callback will be implicitly passed to reject().
   */
  constructor (callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);

  /**
   * onFulfilled is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
   * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
   * Both callbacks have a single parameter , the fulfillment value or rejection reason.
   * "then" returns a new promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
   * If an error is thrown in the callback, the returned promise rejects with that error.
   *
   * @param onFulfilled called when/if "promise" resolves
   * @param onRejected called when/if "promise" rejects
   */
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;

  /**
   * Sugar for promise.then(undefined, onRejected)
   *
   * @param onRejected called when/if "promise" rejects
   */
  catch <U> (onRejected?: (error: any) => U | Thenable<U>): Promise<U>;

  /**
   * Make a new promise from the thenable.
   * A thenable is promise-like in as far as it has a "then" method.
   */
  static resolve (): Promise<void>;
  static resolve <R> (value: R | Thenable<R>): Promise<R>;

  /**
   * Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an instanceof Error
   */
  static reject <R> (error: any): Promise<R>;

  /**
   * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
   * the array passed to all can be a mixture of promise-like objects and other objects.
   * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
   */
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>, T10 | Thenable<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
  static all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
  static all<T1, T2, T3, T4, T5, T6>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
  static all<T1, T2, T3, T4, T5>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>]): Promise<[T1, T2, T3, T4, T5]>;
  static all<T1, T2, T3, T4>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>]): Promise<[T1, T2, T3, T4]>;
  static all<T1, T2, T3>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>]): Promise<[T1, T2, T3]>;
  static all<T1, T2>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>]): Promise<[T1, T2]>;
  static all<T1>(values: [T1 | Thenable<T1>]): Promise<[T1]>;
  static all<TAll>(values: Array<TAll | Thenable<TAll>>): Promise<TAll[]>;

  /**
   * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
   */
  static race <R> (promises: (R | Thenable<R>)[]): Promise<R>;
}

/**
 * The polyfill method will patch the global environment (in this case to the Promise name) when called.
 */
export function polyfill (): void;
}
declare module '~iridium~mongodb~es6-promise' {
export * from '~iridium~mongodb~es6-promise/dist/es6-promise';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/Think7/typings-mongodb/3a50a13eeb9fbb63f8759200dcb2bf576ff33285/mongodb.d.ts
declare module '~iridium~mongodb/mongodb' {
// Type definitions for MongoDB v2.1
// Project: https://github.com/mongodb/node-mongodb-native/tree/2.1
// Definitions by:  Andrew <https://github.com/Think7> 
//                  Federico Caselli <https://github.com/CaselIT> 
// Definitions: https://github.com/Think7/typings-mongodb

// Documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/

// Use typings to install this type definition https://github.com/typings/typings

import {EventEmitter} from 'events';
import {Promise} from '~iridium~mongodb~es6-promise';

// Class documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/MongoClient.html
export class MongoClient {
    constructor();

    static connect(uri: string, callback: MongoCallback<Db>): void;
    static connect(uri: string, options?: MongoClientOptions): Promise<Db>;
    static connect(uri: string, options: MongoClientOptions, callback: MongoCallback<Db>): void;

    connect(uri: string, callback: MongoCallback<Db>): void;
    connect(uri: string, options?: MongoClientOptions): Promise<Db>;
    connect(uri: string, options: MongoClientOptions, callback: MongoCallback<Db>): void;
}

export interface MongoCallback<T> {
    (error: MongoError, result: T): void;
}
    
// http://mongodb.github.io/node-mongodb-native/2.1/api/MongoError.html
export class MongoError extends Error {
    constructor(message: string);
    static create(options: Object): MongoError;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/MongoClient.html#.connect
export interface MongoClientOptions {
    uri_decode_auth?: boolean;
    db?: DbCreateOptions;
    server?: ServerOptions;
    replSet?: ReplSetOptions;
    mongos?: MongosOptions;
    promiseLibrary?: Object;
}
  
// See : http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html
export interface DbCreateOptions {
    authSource?: string;
    //  the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = ‘majority’ or tag acknowledges the write.
    w?: number | string;
    // set the timeout for waiting for write concern to finish (combines with w option).
    wtimeout?: number;
    j?: boolean;
    // use c++ bson parser. default:false.
    native_parser?: boolean;
    // force server to create _id fields instead of client. default:false.
    forceServerObjectId?: boolean;
    serializeFunctions?: boolean;
    ignoreUndefined?: boolean;
    // peform operations using raw bson buffers. default:false.
    raw?: boolean;
    // when deserializing a Long will fit it into a Number if it’s smaller than 53 bits. default:true.
    promoteLongs?: boolean;
    bufferMaxEntries?: number;
    // the prefered read preference. use 'ReadPreference' class.
    readPreference?: ReadPreference | string;
    // custom primary key factory to generate _id values (see Custom primary keys).
    pkFactory?: Object;
    promiseLibrary?: Object;
    readConcern?: { level?: Object };
}

// See http://mongodb.github.io/node-mongodb-native/2.1/api/ReadPreference.html
export class ReadPreference {
    constructor(mode: string, tags: Object);
    mode: string;
    tags: any;
    static PRIMARY: string;
    static PRIMARY_PREFERRED: string;
    static SECONDARY: string;
    static SECONDARY_PREFERRED: string;
    static NEAREST: string;
    isValid(mode: string): boolean;
    static isValid(mode: string): boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Server.html
export interface SocketOptions {
    // Reconnect on error. default:false
    autoReconnect?: boolean;
    // TCP Socket NoDelay option. default:true
    noDelay?: boolean;
    // TCP KeepAlive on the socket with a X ms delay before start. default:0
    keepAlive?: number;
    // TCP Connection timeout setting. default 0
    connectTimeoutMS?: number;
    // TCP Socket timeout setting. default 0
    socketTimeoutMS?: number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Server.html
export interface ServerOptions {
    // - specify the number of connections in the pool default:5
    poolSize?: number;
    ssl?: boolean;
    sslValidate?: Object;
    checkServerIdentity?: boolean | Function;
    sslCA?: Array<Buffer | string>;
    sslCert?: Buffer | string;
    sslKey?: Buffer | string;
    sslPass?: Buffer | string;
    socketOptions?: SocketOptions;
    reconnectTries?: number;
    reconnectInterval?: number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/ReplSet.html
export interface ReplSetOptions {
    ha?: boolean;
    haInterval?: number;
    replicaSet?: string;
    secondaryAcceptableLatencyMS?: number;
    connectWithNoPrimary?: boolean;
    // - specify the number of connections in the pool default:5
    poolSize?: number;
    ssl?: boolean;
    sslValidate?: Object;
    checkServerIdentity?: boolean | Function;
    sslCA?: Array<Buffer | string>;
    sslCert?: Buffer | string;
    sslKey?: Buffer | string;
    sslPass?: Buffer | string;
    socketOptions?: SocketOptions;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Mongos.html
export interface MongosOptions {
    ha?: boolean;
    haInterval?: number;
    // - specify the number of connections in the pool default:5
    poolSize?: number;
    ssl?: boolean;
    sslValidate?: Object;
    checkServerIdentity?: boolean | Function;
    sslCA?: Array<Buffer | string>;
    sslCert?: Buffer | string;
    sslKey?: Buffer | string;
    sslPass?: Buffer | string;
    socketOptions?: SocketOptions;
}
  
// Class documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html
export class Db extends EventEmitter {
    constructor(databaseName: string, serverConfig: Server | ReplSet | Mongos, options?: DbCreateOptions);

    serverConfig: Server | ReplSet | Mongos;
    bufferMaxEntries: number;
    databaseName: string;
    options: any;
    native_parser: boolean;
    slaveOk: boolean;
    writeConcern: any;

    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#addUser
    addUser(username: string, password: string, callback: MongoCallback<any>): void;
    addUser(username: string, password: string, options?: DbAddUserOptions): Promise<any>;
    addUser(username: string, password: string, options: DbAddUserOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#admin
    admin(): Admin;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#authenticate
    authenticate(userName: string, password: string, callback: MongoCallback<any>): void;
    authenticate(userName: string, password: string, options?: { authMechanism: string }): Promise<any>;
    authenticate(userName: string, password: string, options: { authMechanism: string }, callback: MongoCallback<any>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#close
    close(callback: MongoCallback<void>): void;
    close(forceClose?: boolean): Promise<void>;
    close(forceClose: boolean, callback: MongoCallback<void>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#collection
    collection(name: string): Collection;
    collection(name: string, callback: MongoCallback<Collection>): Collection;
    collection(name: string, options: DbCollectionOptions, callback: MongoCallback<Collection>): Collection;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#collections
    collections(): Promise<Collection[]>;
    collections(callback: MongoCallback<Collection[]>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#command
    command(command: Object, callback?: MongoCallback<any>): void;
    command(command: Object, options?: { readPreference: ReadPreference | string }): Promise<any>;
    command(command: Object, options: { readPreference: ReadPreference | string }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#createCollection
    createCollection(name: string, callback: MongoCallback<Collection>): void;
    createCollection(name: string, options?: CollectionCreateOptions): Promise<Collection>;
    createCollection(name: string, options: CollectionCreateOptions, callback: MongoCallback<Collection>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#createIndex
    createIndex(name: string, fieldOrSpec: string | Object, callback: MongoCallback<any>): void;
    createIndex(name: string, fieldOrSpec: string | Object, options?: IndexOptions): Promise<any>;
    createIndex(name: string, fieldOrSpec: string | Object, options: IndexOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#db
    db(dbName: string): Db;
    db(dbName: string, options: { noListener?: boolean, returnNonCachedInstance?: boolean }): Db;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#dropCollection
    dropCollection(name: string): Promise<any>;
    dropCollection(name: string, callback: MongoCallback<any>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#dropDatabase
    dropDatabase(): Promise<any>;
    dropDatabase(callback: MongoCallback<any>): void;
    
    //deprecated http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#ensureIndex
    // ensureIndex(collectionName: any, fieldOrSpec: any, options: IndexOptions, callback: Function): void;
    //deprecated http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#eval
    // eval(code: any, parameters: any[], options?: any, callback?: MongoCallback<any>): void;
    
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#executeDbAdminCommand
    executeDbAdminCommand(command: Object, callback: MongoCallback<any>): void;
    executeDbAdminCommand(command: Object, options?: { readPreference?: ReadPreference | string, maxTimeMS?: number }): Promise<any>;
    executeDbAdminCommand(command: Object, options: { readPreference?: ReadPreference | string, maxTimeMS?: number }, callback: MongoCallback<any>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#indexInformation
    indexInformation(name: string, callback: MongoCallback<any>): void;
    indexInformation(name: string, options?: { full?: boolean, readPreference?: ReadPreference | string }): Promise<any>;
    indexInformation(name: string, options: { full?: boolean, readPreference?: ReadPreference | string }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#listCollections
    listCollections(filter: { name?: string }, options?: { batchSize?: number, readPreference?: ReadPreference | string }): CommandCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#logout
    logout(callback: MongoCallback<any>): void;
    logout(options?: { dbName?: string }): Promise<any>;
    logout(options: { dbName?: string }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#open
    open(): Promise<Db>;
    open(callback: MongoCallback<Db>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#removeUser
    removeUser(username: string, callback: MongoCallback<any>): void;
    removeUser(username: string, options?: { w?: number | string, wtimeout?: number, j?: boolean }): Promise<any>;
    removeUser(username: string, options: { w?: number | string, wtimeout?: number, j?: boolean }, callback: MongoCallback<any>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#renameCollection
    renameCollection(fromCollection: string, toCollection: string, callback: MongoCallback<Collection>): void;
    renameCollection(fromCollection: string, toCollection: string, options?: { dropTarget?: boolean }): Promise<Collection>;
    renameCollection(fromCollection: string, toCollection: string, options: { dropTarget?: boolean }, callback: MongoCallback<Collection>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#stats
    stats(callback: MongoCallback<any>): void;
    stats(options?: { scale?: number }): Promise<any>;
    stats(options: { scale?: number }, callback: MongoCallback<any>): void;
}


  
// Deprecated http://mongodb.github.io/node-mongodb-native/2.1/api/Server.html
export class Server extends EventEmitter {
    constructor(host: string, port: number, options?: ServerOptions);

    connections(): Array<any>;
}
  
// Deprecated http://mongodb.github.io/node-mongodb-native/2.1/api/ReplSet.html
export class ReplSet extends EventEmitter {
    constructor(servers: Array<Server>, options?: ReplSetOptions);

    connections(): Array<any>;
}
  
// Deprecated http://mongodb.github.io/node-mongodb-native/2.1/api/ReplSet.html
export class Mongos extends EventEmitter {
    constructor(servers: Array<Server>, options?: MongosOptions);

    connections(): Array<any>;
}
// http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#addUser
export interface DbAddUserOptions {
    w?: string | number;
    wtimeout?: number;
    j?: boolean;
    customData?: Object;
    roles?: Object[];
}

//http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#createCollection
export interface CollectionCreateOptions {
    w?: number | string;
    wtimeout?: number;
    j?: boolean;
    raw?: boolean;
    pkFactory?: Object;
    readPreference?: ReadPreference | string;
    serializeFunctions?: boolean;
    strict?: boolean;
    capped?: boolean;
    size?: number;
    max?: number;
    autoIndexId?: boolean;
}
  
// http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#collection
export interface DbCollectionOptions {
    w?: number | string;
    wtimeout?: number;
    j?: boolean;
    raw?: boolean;
    pkFactory?: Object;
    readPreference?: ReadPreference | string;
    serializeFunctions?: boolean;
    strict?: boolean;
    readConcern?: { level: Object };
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Db.html#createIndex
export interface IndexOptions {
    // The write concern.
    w?: number | string;
    // The write concern timeout.
    wtimeout?: number;
    // Specify a journal write concern.
    j?: boolean;
    // Creates an unique index.
    unique?: boolean;
    // Creates a sparse index.
    sparse?: boolean;
    // Creates the index in the background, yielding whenever possible.
    background?: boolean;
    // A unique index cannot be created on a key that has pre-existing duplicate values.
    // If you would like to create the index anyway, keeping the first document the database indexes and
    // deleting all subsequent documents that have duplicate value
    dropDups?: boolean;
    // For geo spatial indexes set the lower bound for the co-ordinates.
    min?: number;
    // For geo spatial indexes set the high bound for the co-ordinates.
    max?: number;
    // Specify the format version of the indexes.
    v?: number;
    // Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
    expireAfterSeconds?: number;
    // Override the auto generated index name (useful if the resulting name is larger than 128 bytes)
    name?: string;
}
  
// http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html
export interface Admin {
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#addUser
    addUser(username: string, password: string, callback: MongoCallback<any>): void;
    addUser(username: string, password: string, options?: AddUserOptions): Promise<any>;
    addUser(username: string, password: string, options: AddUserOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#authenticate
    authenticate(username: string, callback: MongoCallback<any>): void;
    authenticate(username: string, password?: string): Promise<any>;
    authenticate(username: string, password: string, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#buildInfo
    buildInfo(): Promise<any>;
    buildInfo(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#command
    command(command: Object, callback: MongoCallback<any>): void;
    command(command: Object, options?: { readPreference?: ReadPreference | string, maxTimeMS?: number }): Promise<any>;
    command(command: Object, options: { readPreference?: ReadPreference | string, maxTimeMS?: number }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#listDatabases
    listDatabases(): Promise<any>;
    listDatabases(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#logout
    logout(): Promise<any>;
    logout(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#ping
    ping(): Promise<any>;
    ping(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#profilingInfo
    profilingInfo(): Promise<any>;
    profilingInfo(callback: MongoCallback<any>): void    
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#profilingLevel
    profilingLevel(): Promise<any>;
    profilingLevel(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#removeUser
    removeUser(username: string, callback: MongoCallback<any>): void;
    removeUser(username: string, options?: FSyncOptions): Promise<any>;
    removeUser(username: string, options: FSyncOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#replSetGetStatus
    replSetGetStatus(): Promise<any>;
    replSetGetStatus(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#serverInfo
    serverInfo(): Promise<any>;
    serverInfo(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#serverStatus
    serverStatus(): Promise<any>;
    serverStatus(callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#setProfilingLevel
    setProfilingLevel(level: string): Promise<any>;
    setProfilingLevel(level: string, callback: MongoCallback<any>): void
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#validateCollection
    validateCollection(collectionNme: string, callback: MongoCallback<any>): void;
    validateCollection(collectionNme: string, options?: Object): Promise<any>;
    validateCollection(collectionNme: string, options: Object, callback: MongoCallback<any>): void;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#addUser
export interface AddUserOptions {
    w?: number | string;
    wtimeout?: number;
    j?: boolean;
    fsync: boolean;
    customData?: Object;
    roles?: Object[]
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Admin.html#removeUser
export interface FSyncOptions {
    w?: number | string;
    wtimeout?: number;
    j?: boolean;
    fsync?: boolean
}

// Class documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/ObjectID.html
export class ObjectID {
    constructor(s?: string | number);

    generationTime: number;
    
    // Creates an ObjectID from a hex string representation of an ObjectID.
    // hexString – create a ObjectID from a passed in 24 byte hexstring.
    static createFromHexString(hexString: string): ObjectID;
    // Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
    // time – an integer number representing a number of seconds.
    static createFromTime(time: number): ObjectID;
    // Checks if a value is a valid bson ObjectId
    // id - Value to be checked
    static isValid(id: string | number): boolean;
    //Compares the equality of this ObjectID with otherID.
    equals(otherID: ObjectID): boolean;
    // Generate a 12 byte id string used in ObjectID's
    // time - optional parameter allowing to pass in a second based timestamp
    generate(time?: number): string;
    // Returns the generation date (accurate up to the second) that this ID was generated.
    getTimestamp(): Date;
    // Returns the ObjectID id as a 24 byte hex string representation
    toHexString(): string;
}

// Class documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/Binary.html
export class Binary {
    constructor(buffer: Buffer, subType?: number);

    static SUBTYPE_BYTE_ARRAY: number;
    static SUBTYPE_DEFAULT: number;
    static SUBTYPE_FUNCTION: number;
    static SUBTYPE_MD5: number;
    static SUBTYPE_USER_DEFINED: number;
    static SUBTYPE_UUID: number;
    static SUBTYPE_UUID_OLD: number;

    // The length of the binary.
    length(): number;
    // Updates this binary with byte_value
    put(byte_value: number | string): void;
    // Reads length bytes starting at position.
    read(position: number, length: number): Buffer;
    // Returns the value of this binary as a string.
    value(): string;
    // Writes a buffer or string to the binary
    write(buffer: Buffer | string, offset: number): void;
}
//http://mongodb.github.io/node-mongodb-native/2.1/api/Double.html
export class Double {
    constructor(value: number);

    valueOf(): number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Long.html
export class Long {
    constructor(low: number, high: number);

    static MAX_VALUE: Long;
    static MIN_VALUE: Long;
    static NEG_ONE: Long;
    static ONE: Long;
    static ZERO: Long;

    static fromBits(lowBits: number, highBits: number): Long;
    static fromInt(value: number): Long;
    static fromNumber(value: number): Long;
    static fromString(str: string, radix?: number): Long;

    add(other: Long): Long;
    and(other: Long): Long;
    compare(other: Long): number;
    div(other: Long): Long;
    equals(other: Long): boolean;
    getHighBits(): number;
    getLowBits(): number;
    getLowBitsUnsigned(): number;
    getNumBitsAbs(): number;
    greaterThan(other: Long): number;
    greaterThanOrEqual(other: Long): number;
    isNegative(): boolean;
    isOdd(): boolean;
    isZero(): boolean;
    lessThan(other: Long): boolean;
    lessThanOrEqual(other: Long): boolean;
    modulo(other: Long): Long;
    multiply(other: Long): Long;
    negate(): Long;
    not(): Long;
    notEquals(other: Long): boolean;
    or(other: Long): Long;
    shiftLeft(other: number): Long;
    shiftRight(other: number): Long;
    shiftRightUnsigned(other: number): Long;
    subtract(other: Long): Long;
    toInt(): number;
    toJSON(): string;
    toNumber(): number;
    toString(radix?: number): string;
    xor(other: Long): Long;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/MaxKey.html
export class MaxKey { }
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/MinKey.html
export class MinKey { }
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Timestamp.html
export class Timestamp {
    constructor(low: number, high: number);

    static MAX_VALUE: Timestamp;
    static MIN_VALUE: Timestamp;
    static NEG_ONE: Timestamp;
    static ONE: Timestamp;
    static ZERO: Timestamp;

    static fromBits(lowBits: number, highBits: number): Timestamp;
    static fromInt(value: number): Timestamp;
    static fromNumber(value: number): Timestamp;
    static fromString(str: string, radix?: number): Timestamp;

    add(other: Timestamp): Timestamp;
    and(other: Timestamp): Timestamp;
    compare(other: Timestamp): number;
    div(other: Timestamp): Timestamp;
    equals(other: Timestamp): boolean;
    getHighBits(): number;
    getLowBits(): number;
    getLowBitsUnsigned(): number;
    getNumBitsAbs(): number;
    greaterThan(other: Timestamp): number;
    greaterThanOrEqual(other: Timestamp): number;
    isNegative(): boolean;
    isOdd(): boolean;
    isZero(): boolean;
    lessThan(other: Timestamp): boolean;
    lessThanOrEqual(other: Timestamp): boolean;
    modulo(other: Timestamp): Timestamp;
    multiply(other: Timestamp): Timestamp;
    negate(): Timestamp;
    not(): Timestamp;
    notEquals(other: Timestamp): boolean;
    or(other: Timestamp): Timestamp;
    shiftLeft(other: number): Timestamp;
    shiftRight(other: number): Timestamp;
    shiftRightUnsigned(other: number): Timestamp;
    subtract(other: Timestamp): Timestamp;
    toInt(): number;
    toJSON(): string;
    toNumber(): number;
    toString(radix?: number): string;
    xor(other: Timestamp): Timestamp;
}

// Documentation : http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html
export interface Collection {
    // Get the collection name.
    collectionName: string;
    // Get the full collection namespace.
    namespace: string;
    // The current write concern values.
    writeConcern: any;
    // The current read concern values.
    readConcern: any;
    // Get current index hint for collection.
    hint: any;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#aggregate
    aggregate(pipeline: Object[], callback: MongoCallback<any>): void | AggregationCursor;
    aggregate(pipeline: Object[], options: CollectionAggrigationOptions, callback: MongoCallback<any>): void | AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#bulkWrite
    bulkWrite(operations: Object[], callback: MongoCallback<BulkWriteOpResultObject>): void
    bulkWrite(operations: Object[], options?: CollectionBluckWriteOptions): Promise<BulkWriteOpResultObject>
    bulkWrite(operations: Object[], options: CollectionBluckWriteOptions, callback: MongoCallback<BulkWriteOpResultObject>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#count
    count(query: Object, callback: MongoCallback<number>): void;
    count(query: Object, options?: MongoCountPreferences): Promise<number>;
    count(query: Object, options: MongoCountPreferences, callback: MongoCallback<number>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#createIndex
    createIndex(fieldOrSpec: string | any, callback: MongoCallback<string>): void;
    createIndex(fieldOrSpec: string | any, options?: IndexOptions): Promise<string>;
    createIndex(fieldOrSpec: string | any, options: IndexOptions, callback: MongoCallback<string>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#createIndexes and http://docs.mongodb.org/manual/reference/command/createIndexes/
    createIndexes(indexSpecs: Object[]): Promise<any>;
    createIndexes(indexSpecs: Object[], callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#deleteMany
    deleteMany(filter: Object, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    deleteMany(filter: Object, options?: CollectionOptions): Promise<DeleteWriteOpResultObject>;
    deleteMany(filter: Object, options: CollectionOptions, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#deleteOne
    deleteOne(filter: Object, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    deleteOne(filter: Object, options?: { w?: number | string, wtimmeout?: number, j?: boolean, bypassDocumentValidation?: boolean }): Promise<DeleteWriteOpResultObject>;
    deleteOne(filter: Object, options: { w?: number | string, wtimmeout?: number, j?: boolean, bypassDocumentValidation?: boolean }, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#distinct
    distinct(key: string, query: Object, callback: MongoCallback<any>): void
    distinct(key: string, query: Object, options?: { readPreference?: ReadPreference | string }): Promise<any>;
    distinct(key: string, query: Object, options: { readPreference?: ReadPreference | string }, callback: MongoCallback<any>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#drop
    drop(): Promise<any>;
    drop(callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#dropIndex
    dropIndex(indexName: string, callback: MongoCallback<any>): void;
    dropIndex(indexName: string, options?: CollectionOptions): Promise<any>;
    dropIndex(indexName: string, options: CollectionOptions, callback: MongoCallback<any>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#dropIndexes
    dropIndexes(): Promise<any>;
    dropIndexes(callback?: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#find
    find(query: Object): Cursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOneAndDelete
    findOneAndDelete(filter: Object, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    findOneAndDelete(filter: Object, options?: { projection?: Object, sort?: Object, maxTimeMS?: number }): Promise<FindAndModifyWriteOpResultObject>;
    findOneAndDelete(filter: Object, options: { projection?: Object, sort?: Object, maxTimeMS?: number }, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOneAndReplace
    findOneAndReplace(filter: Object, replacement: Object, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    findOneAndReplace(filter: Object, replacement: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>;
    findOneAndReplace(filter: Object, replacement: Object, options: FindOneAndReplaceOption, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOneAndUpdate
    findOneAndUpdate(filter: Object, update: Object, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    findOneAndUpdate(filter: Object, update: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>;
    findOneAndUpdate(filter: Object, update: Object, options: FindOneAndReplaceOption, callback: MongoCallback<FindAndModifyWriteOpResultObject>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#geoHaystackSearch
    geoHaystackSearch(x: number, y: number, callback: MongoCallback<any>): void;
    geoHaystackSearch(x: number, y: number, options?: GeoHaystackSearchOptions): Promise<any>;
    geoHaystackSearch(x: number, y: number, options: GeoHaystackSearchOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#geoNear
    geoNear(x: number, y: number, callback: MongoCallback<any>): void;
    geoNear(x: number, y: number, options?: GeoNearOptions): Promise<any>;
    geoNear(x: number, y: number, options: GeoNearOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#group
    group(keys: Object | Array<any> | Function | Code, condition: Object, initial: Object, reduce: Function | Code, finalize: Function | Code, command: boolean, callback: MongoCallback<any>): void;
    group(keys: Object | Array<any> | Function | Code, condition: Object, initial: Object, reduce: Function | Code, finalize: Function | Code, command: boolean, options?: { readPreference?: ReadPreference | string }): Promise<any>;
    group(keys: Object | Array<any> | Function | Code, condition: Object, initial: Object, reduce: Function | Code, finalize: Function | Code, command: boolean, options: { readPreference?: ReadPreference | string }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#indexes
    indexes(): Promise<any>;
    indexes(callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#indexExists
    indexExists(indexes: string | string[]): Promise<boolean>;
    indexExists(indexes: string | string[], callback: MongoCallback<boolean>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#indexInformation
    indexInformation(callback: MongoCallback<any>): void;
    indexInformation(options?: { full: boolean }): Promise<any>;
    indexInformation(options: { full: boolean }, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#initializeOrderedBulkOp
    initializeOrderedBulkOp(options: CollectionOptions): OrderedBulkOperation; 	
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#initializeUnorderedBulkOp
    initializeUnorderedBulkOp(options: CollectionOptions): UnorderedBulkOperation; 	
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#insertMany
    insertMany(docs: Object[], callback: MongoCallback<InsertWriteOpResult>): void
    insertMany(docs: Object[], options?: CollectionInsertManyOptions): Promise<InsertWriteOpResult>;
    insertMany(docs: Object[], options: CollectionInsertManyOptions, callback: MongoCallback<InsertWriteOpResult>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#insertOne
    insertOne(docs: Object, callback: MongoCallback<InsertOneWriteOpResult>): void
    insertOne(docs: Object, options?: CollectionInsertOneOptions): Promise<InsertOneWriteOpResult>;
    insertOne(docs: Object, options: CollectionInsertOneOptions, callback: MongoCallback<InsertOneWriteOpResult>): void
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#isCapped
    isCapped(): Promise<any>;
    isCapped(callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#listIndexes
    listIndexes(options?: { batchSize?: number, readPreference?: ReadPreference | string }): CommandCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#mapReduce
    mapReduce(map: Function | string, reduce: Function | string, callback: MongoCallback<any>): void;
    mapReduce(map: Function | string, reduce: Function | string, options?: MapReduceOptions): Promise<any>;
    mapReduce(map: Function | string, reduce: Function | string, options: MapReduceOptions, callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#options
    options(): Promise<any>;
    options(callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#parallelCollectionScan
    parallelCollectionScan(callback: MongoCallback<Cursor[]>): void;
    parallelCollectionScan(options?: ParallelCollectionScanOptions): Promise<Cursor[]>;
    parallelCollectionScan(options: ParallelCollectionScanOptions, callback: MongoCallback<Cursor[]>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#reIndex
    reIndex(): Promise<any>;
    reIndex(callback: MongoCallback<any>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#rename
    rename(newName: string, callback: MongoCallback<Collection>): void;
    rename(newName: string, options?: { dropTarget?: boolean }): Promise<Collection>;
    rename(newName: string, options: { dropTarget?: boolean }, callback: MongoCallback<Collection>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#replaceOne
    replaceOne(filter: Object, doc: Object, callback: MongoCallback<UpdateWriteOpResult>): void;
    replaceOne(filter: Object, doc: Object, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>;
    replaceOne(filter: Object, doc: Object, options: ReplaceOneOptions, callback: MongoCallback<UpdateWriteOpResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#stats
    stats(callback: MongoCallback<CollStats>): void;
    stats(options?: { scale: number }): Promise<CollStats>;
    stats(options: { scale: number }, callback: MongoCallback<CollStats>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#updateMany
    updateMany(filter: Object, update: Object, callback: MongoCallback<UpdateWriteOpResult>): void;
    updateMany(filter: Object, update: Object, options?: { upsert?: boolean; w?: any; wtimeout?: number; j?: boolean; }): Promise<UpdateWriteOpResult>;
    updateMany(filter: Object, update: Object, options: { upsert?: boolean; w?: any; wtimeout?: number; j?: boolean; }, callback: MongoCallback<UpdateWriteOpResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#updateOne
    updateOne(filter: Object, update: Object, callback: MongoCallback<UpdateWriteOpResult>): void;
    updateOne(filter: Object, update: Object, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>;
    updateOne(filter: Object, update: Object, options: ReplaceOneOptions, callback: MongoCallback<UpdateWriteOpResult>): void;
}
  
// Documentation: http://docs.mongodb.org/manual/reference/command/collStats/
//TODO complete this
export interface CollStats {
    // Namespace.
    ns: string;
    // Number of documents.
    count: number;
    // Collection size in bytes.
    size: number;
    // Average object size in bytes.
    avgObjSize: number;
    // (Pre)allocated space for the collection in bytes.
    storageSize: number;
    // Number of extents (contiguously allocated chunks of datafile space).
    numExtents: number;
    // Number of indexes.
    nindexes: number;
    // Size of the most recently created extent in bytes.
    lastExtentSize: number;
    // Padding can speed up updates if documents grow.
    paddingFactor: number;
    userFlags: number;
    // Total index size in bytes.
    totalIndexSize: number;
    // Size of specific indexes in bytes.
    indexSizes: {
        _id_: number;
        username: number;
    };
    capped: boolean;
    maxSize: boolean;
    wiredTiger: any;
    indexDetails: any;
    ok: number
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#aggregate
export interface CollectionAggrigationOptions {
    readPreference?: ReadPreference | string;
    // Return the query as cursor, on 2.6 > it returns as a real cursor
    // on pre 2.6 it returns as an emulated cursor.
    cursor?: { batchSize: number };
    // Explain returns the aggregation execution plan (requires mongodb 2.6 >).
    explain?: boolean;
    // lets the server know if it can use disk to store
    // temporary results for the aggregation (requires mongodb 2.6 >).
    allowDiskUse?: boolean;
    // specifies a cumulative time limit in milliseconds for processing operations
    // on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
    maxTimeMS?: boolean;
    // Allow driver to bypass schema validation in MongoDB 3.2 or higher.
    bypassDocumentValidation?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#insertMany
export interface CollectionInsertManyOptions {
    // The write concern.
    w?: number | string;
    // The write concern timeout.
    wtimeout?: number;
    // Specify a journal write concern.
    j?: boolean;
    // Serialize functions on any object.
    serializeFunctions?: boolean;
    //Force server to assign _id values instead of driver.
    forceServerObjectId?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#bulkWrite
export interface CollectionBluckWriteOptions {
    // The write concern.
    w?: number | string;
    // The write concern timeout.
    wtimeout?: number;
    // Specify a journal write concern.
    j?: boolean;
    // Serialize functions on any object.
    serializeFunctions?: boolean;
    // Execute write operation in ordered or unordered fashion.
    ordered?: boolean;
    // Allow driver to bypass schema validation in MongoDB 3.2 or higher.
    bypassDocumentValidation?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~BulkWriteOpResult
export interface BulkWriteOpResultObject {
    insertedCount?: number;
    matchedCount?: number;
    modifiedCount?: number;
    deletedCount?: number;
    upsertedCount?: number;
    insertedIds?: any;
    upsertedIds?: any;
    result?: any;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#count
export interface MongoCountPreferences {
    // The limit of documents to count.
    limit?: number;
    // The number of documents to skip for the count.
    skip?: boolean;
    // An index name hint for the query.
    hint?: string;
    // The preferred read preference
    readPreference?: ReadPreference | string;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~deleteWriteOpResult  
export interface DeleteWriteOpResultObject {
    //The raw result returned from MongoDB, field will vary depending on server version.
    result: { 	
        //Is 1 if the command executed correctly.
        ok?: number;
        //The total count of documents deleted.
        n?: number;
    }
    //The connection object used for the operation.
    connection?: any;
    //The number of documents deleted.
    deletedCount?: number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~findAndModifyWriteOpResult
export interface FindAndModifyWriteOpResultObject {
    //Document returned from findAndModify command.
    value?: any;
    //The raw lastErrorObject returned from the command.
    lastErrorObject?: any;
    //Is 1 if the command executed correctly.
    ok?: number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOneAndReplace
export interface FindOneAndReplaceOption {
    projection?: Object;
    sort?: Object;
    maxTimeMS?: number;
    upsert?: boolean;
    returnOriginal?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#geoHaystackSearch
export interface GeoHaystackSearchOptions {
    readPreference?: ReadPreference | string;
    maxDistance?: number;
    search?: Object;
    limit?: number;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#geoNear
export interface GeoNearOptions {
    readPreference?: ReadPreference | string;
    num?: number;
    minDistance?: number;
    maxDistance?: number;
    distanceMultiplier?: number;
    query?: Object;
    spherical?: boolean;
    uniqueDocs?: boolean;
    includeLocs?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Code.html
export class Code {
    constructor(code: string | Function, scope?: Object)
    code: string | Function;
    scope: any;
}

//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#deleteMany
export interface CollectionOptions {
    //The write concern.
    w?: number | string;
    //The write concern timeout.
    wtimeout?: number;
    //Specify a journal write concern.
    j?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/OrderedBulkOperation.html
export interface OrderedBulkOperation {
    length: number;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/OrderedBulkOperation.html#execute
    execute(callback: MongoCallback<BulkWriteResult>): void;
    execute(options: FSyncOptions): Promise<BulkWriteResult>;
    execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/OrderedBulkOperation.html#find
    find(selector: Object): FindOperatorsOrdered;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/OrderedBulkOperation.html#insert
    insert(doc: Object): OrderedBulkOperation;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/BulkWriteResult.html
export interface BulkWriteResult {
    ok: number;
    nInserted: number;
    nUpdated: number;
    nUpserted: number;
    nModified: number;
    nRemoved: number;

    getInsertedIds(): Array<Object>;
    getLastOp(): Object;
    getRawResponse(): Object;
    getUpsertedIdAt(index: number): Object;
    getUpsertedIds(): Array<Object>;
    getWriteConcernError(): WriteConcernError;
    getWriteErrorAt(index: number): WriteError;
    getWriteErrorCount(): number;
    getWriteErrors(): Array<Object>;
    hasWriteErrors(): boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/WriteError.html
export interface WriteError {
    //Write concern error code.
    code: number; 	
    //Write concern error original bulk operation index.
    index: number; 	
    //Write concern error message.
    errmsg: string;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/WriteConcernError.html
export interface WriteConcernError {
    //Write concern error code.
    code: number; 	
    //Write concern error message.
    errmsg: string;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/FindOperatorsOrdered.html
export interface FindOperatorsOrdered {
    delete(): OrderedBulkOperation;
    deleteOne(): OrderedBulkOperation;
    replaceOne(doc: Object): OrderedBulkOperation;
    update(doc: Object): OrderedBulkOperation;
    updateOne(doc: Object): OrderedBulkOperation;
    upsert(): FindOperatorsOrdered;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/UnorderedBulkOperation.html
export interface UnorderedBulkOperation {
    //http://mongodb.github.io/node-mongodb-native/2.1/api/UnorderedBulkOperation.html#execute
    execute(callback: MongoCallback<BulkWriteResult>): void;
    execute(options: FSyncOptions): Promise<BulkWriteResult>;
    execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/UnorderedBulkOperation.html#find
    find(selector: Object): FindOperatorsUnordered;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/UnorderedBulkOperation.html#insert
    insert(doc: Object): UnorderedBulkOperation;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/FindOperatorsUnordered.html
export interface FindOperatorsUnordered {
    length: number;
    remove(): UnorderedBulkOperation;
    removeOne(): UnorderedBulkOperation;
    replaceOne(doc: Object): UnorderedBulkOperation;
    update(doc: Object): UnorderedBulkOperation;
    updateOne(doc: Object): UnorderedBulkOperation;
    upsert(): FindOperatorsUnordered;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~insertWriteOpResult
export interface InsertWriteOpResult {
    insertedCount: number;
    ops: Array<any>;
    insertedIds: Array<ObjectID>;
    connection: any;
    result: { ok: number, n: number }
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#insertOne
export interface CollectionInsertOneOptions {
    // The write concern.
    w?: number | string;
    // The write concern timeout.
    wtimeout?: number;
    // Specify a journal write concern.
    j?: boolean;
    // Serialize functions on any object.
    serializeFunctions?: boolean;
    //Force server to assign _id values instead of driver.
    forceServerObjectId?: boolean;
    //Allow driver to bypass schema validation in MongoDB 3.2 or higher.
    bypassDocumentValidation?: boolean
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~insertOneWriteOpResult
export interface InsertOneWriteOpResult {
    insertedCount: number;
    ops: Array<any>;
    insertedId: ObjectID;
    connection: any;
    result: { ok: number, n: number }
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#parallelCollectionScan
export interface ParallelCollectionScanOptions {
    readPreference?: ReadPreference | string;
    batchSize?: number;
    numCursors?: number;
    raw?: boolean;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#replaceOne
export interface ReplaceOneOptions {
    upsert?: boolean;
    w?: number | string;
    wtimeout?: number;
    j?: boolean;
    bypassDocumentValidation?: boolean;
}  
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#~updateWriteOpResult
export interface UpdateWriteOpResult {
    result: { ok: number, n: number, nModified: number };
    connection: any;
    matchedCount: number;
    modifiedCount: number;
    upsertedCount: number;
    upsertedId: { _id: ObjectID };
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#mapReduce
export interface MapReduceOptions {
    readPreference?: ReadPreference | string;
    out?: Object;
    query?: Object;
    sort?: Object;
    limit?: number;
    keeptemp?: boolean;
    finalize?: Function | string;
    scope?: Object;
    jsMode?: boolean;
    verbose?: boolean;
    bypassDocumentValidation?: boolean
}
  
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/external-Readable.html
export interface Readable {
    pause(): void;
    pipe(destination: Writable, options?: Object): void;
    read(size: number): string | Buffer | void;
    resume(): void;
    setEncoding(encoding: string): void;
    unpipe(destination?: Writable): void;
    unshift(stream: Buffer | string): void;
    wrap(stream: Stream): void;
}

export interface Writable { }
export interface Stream { }
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#~resultCallback
export type CursorResult = any | void | boolean;
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html
export interface Cursor extends Readable, NodeJS.EventEmitter  {

    sortValue: string;
    timeout: boolean;
    readPreference: ReadPreference;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html
    addCursorFlag(flag: string, value: boolean): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addQueryModifier
    addQueryModifier(name: string, value: boolean): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#batchSize
    batchSize(value: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#clone
    clone(): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close
    close(): Promise<CursorResult>;
    close(callback: MongoCallback<CursorResult>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#comment
    comment(value: string): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#count
    count(applySkipLimit: boolean, callback: MongoCallback<number>): void;
    count(applySkipLimit: boolean, options?: CursorCommentOptions): Promise<number>;
    count(applySkipLimit: boolean, options: CursorCommentOptions, callback: MongoCallback<number>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#explain
    explain(): Promise<CursorResult>;
    explain(callback: MongoCallback<CursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#filter
    filter(filter: Object): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#forEach
    forEach(iterator: IteratorCallback, callback: EndCallback): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#hasNext
    hasNext(): Promise<boolean>;
    hasNext(callback: MongoCallback<boolean>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#hint
    hint(hint: Object): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#isClosed
    isClosed(): boolean;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#limit
    limit(value: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#map
    map(transform: Function): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#max
    max(max: number): Cursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#maxAwaitTimeMS
    maxAwaitTimeMS(value: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#maxScan
    maxScan(maxScan: Object): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#maxTimeMS
    maxTimeMS(value: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#min
    min(min: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#next
    next(): Promise<CursorResult>;
    next(callback: MongoCallback<CursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#pause
    pause(): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#pipe
    pipe(destination: Writable, options?: Object): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#project
    project(value: Object): Cursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#read
    read(size: number): string | Buffer | void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#resume
    resume(): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#next
    returnKey(returnKey: Object): Cursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#rewind
    rewind(): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#setCursorOption
    setCursorOption(field: string, value: Object): Cursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#setEncoding
    setEncoding(encoding: string): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#setReadPreference
    setReadPreference(readPreference: string | ReadPreference): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#showRecordId
    showRecordId(showRecordId: Object): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#skip
    skip(value: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#snapshot
    snapshot(snapshot: Object): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#sort
    sort(keyOrList: string | Object[] | Object | Object, direction?: number): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#stream
    stream(options?: { transform?: Function }): Cursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#toArray
    toArray(): Promise<any[]>;
    toArray(callback: MongoCallback<any[]>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#unpipe
    unpipe(destination?: Writable): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#unshift
    unshift(stream: Buffer | string): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#wrap
    wrap(stream: Stream): void;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#count
export interface CursorCommentOptions {
    skip?: number;
    limit?: number;
    maxTimeMS?: number;
    hint?: string;
    readPreference?: ReadPreference | string;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#~iteratorCallback
export interface IteratorCallback {
    (doc: any): void;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#~endCallback
export interface EndCallback {
    (error: MongoError): void;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#~resultCallback
export type AggregationCursorResult = any | void;
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html
export interface AggregationCursor extends Readable, NodeJS.EventEmitter  {
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#batchSize
    batchSize(value: number): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#clone
    clone(): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#close
    close(): Promise<AggregationCursorResult>;
    close(callback: MongoCallback<AggregationCursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#each
    each(callback: MongoCallback<AggregationCursorResult>): void
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#explain
    explain(): Promise<AggregationCursorResult>;
    explain(callback: MongoCallback<AggregationCursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#geoNear
    geoNear(document: Object): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#group
    group(document: Object): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#isClosed
    isClosed(): boolean;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#limit
    limit(value: number): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#match
    match(document: Object): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#maxTimeMS
    maxTimeMS(value: number): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#next
    next(): Promise<AggregationCursorResult>;
    next(callback: MongoCallback<AggregationCursorResult>): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#out
    out(destination: string): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#pause
    pause(): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#pipe
    pipe(destination: Writable, options?: Object): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#project
    project(document: Object): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#read
    read(size: number): string | Buffer | void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#redact
    redact(document: Object): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#resume
    resume(): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#rewind
    rewind(): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#setEncoding
    setEncoding(encoding: string): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#skip
    skip(value: number): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#sort
    sort(document: Object): AggregationCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#toArray
    toArray(): Promise<Object[]>;
    toArray(callback: MongoCallback<Object[]>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#unpipe
    unpipe(destination?: Writable): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#unshift
    unshift(stream: Buffer | string): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#unwind
    unwind(field: string): AggregationCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/AggregationCursor.html#wrap
    wrap(stream: Stream): void;
}
  
//http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html
export interface CommandCursor extends Readable, NodeJS.EventEmitter {
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#batchSize
    batchSize(value: number): CommandCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#clone
    clone(): CommandCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#close
    close(): Promise<AggregationCursorResult>;
    close(callback: MongoCallback<AggregationCursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#each
    each(callback: MongoCallback<AggregationCursorResult>): void
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#isClosed
    isClosed(): boolean;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#maxTimeMS
    maxTimeMS(value: number): CommandCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#next
    next(): Promise<AggregationCursorResult>;
    next(callback: MongoCallback<AggregationCursorResult>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#pause
    pause(): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#pipe
    pipe(destination: Writable, options?: Object): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#read
    read(size: number): string | Buffer | void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#resume
    resume(): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#rewind
    rewind(): CommandCursor;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#setEncoding
    setEncoding(encoding: string): void;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#setReadPreference
    setReadPreference(readPreference: string | ReadPreference): CommandCursor;
    // http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#toArray
    toArray(): Promise<Object[]>;
    toArray(callback: MongoCallback<Object[]>): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#unpipe
    unpipe(destination?: Writable): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#unshift
    unshift(stream: Buffer | string): void;
    //http://mongodb.github.io/node-mongodb-native/2.1/api/CommandCursor.html#wrap
    wrap(stream: Stream): void;
}
}
declare module '~iridium~mongodb' {
export * from '~iridium~mongodb/mongodb';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/middleware/Express.d.ts
declare module '~iridium/dist/lib/middleware/Express' {
import * as http from 'http';
import { Core } from '~iridium/dist/lib/Core';
/**
 * A factory method which creates Express/Connect compatible middleware functions to inject
 * a "db" field on your request objects as well as ensuring that the Iridium Core is connected
 * to a MongoDB database before handling any requests.
 *
 * @internal
 */
export function ExpressMiddlewareFactory(core: Core): ExpressMiddleware;
/**
 * An Express/Connect compatible middleware function which injects req.db and ensures that the Iridium Core
 * has an active database connection before continuing the request handling process.
 */
export interface ExpressMiddleware {
    (req: http.ServerRequest, res: http.ServerResponse, next: (err?: Error, route?: String) => void): any;
}
}
declare module 'iridium/dist/lib/middleware/Express' {
export * from '~iridium/dist/lib/middleware/Express';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Core.d.ts
declare module '~iridium/dist/lib/Core' {
import * as Bluebird from '~iridium~bluebird';
import * as MongoDB from '~iridium~mongodb';
import { Configuration } from '~iridium/dist/lib/Configuration';
import { Plugin } from '~iridium/dist/lib/Plugins';
import * as ExpressMiddleware from '~iridium/dist/lib/middleware/Express';
import { Cache } from '~iridium/dist/lib/Cache';
/**
 * The Iridium Core, responsible for managing the connection to the database as well
 * as any plugins you are making use of.
 *
 * Generally you will subclass this to provide your own custom core with the models you
 * make use of within your application.
 */
export class Core {
    /**
     * Creates a new Iridium Core instance connected to the specified MongoDB instance
     * @param {Iridium.IridiumConfiguration} config The config object defining the database to connect to
     * @constructs Core
     */
    constructor(config: Configuration);
    /**
     * Creates a new Iridium Core instance connected to the specified MongoDB instance
     * @param {String} url The URL of the MongoDB instance to connect to
     * @param {Iridium.IridiumConfiguration} config The config object made available as settings
     * @constructs Core
     */
    constructor(uri: string, config?: Configuration);
    private mongoConnectAsyc;
    private _plugins;
    private _url;
    private _config;
    private _connection;
    private _cache;
    private _connectPromise;
    /**
     * Gets the plugins registered with this Iridium Core
     * @returns {[Iridium.Plugin]}
     */
    plugins: Plugin[];
    /**
     * Gets the configuration specified in the construction of this
     * Iridium Core.
     * @returns {Iridium.Configuration}
     */
    settings: Configuration;
    /**
     * Gets the currently active database connection for this Iridium
     * Core.
     * @returns {MongoDB.Db}
     */
    connection: MongoDB.Db;
    /**
     * Gets the URL used to connect to MongoDB
     * @returns {String}
     */
    url: string;
    /**
     * Gets the cache used to store objects retrieved from the database for performance reasons
     * @returns {cache}
     */
    cache: Cache;
    /**
     * Registers a new plugin with this Iridium Core
     * @param {Iridium.Plugin} plugin The plugin to register with this Iridium Core
     * @returns {Iridium.Core}
     */
    register(plugin: Plugin): Core;
    /**
     * Connects to the database server specified in the provided configuration
     * @param {function(Error, Iridium.Core)} [callback] A callback to be triggered once the connection is established.
     * @returns {Promise}
     */
    connect(callback?: (err: Error, core: Core) => any): Bluebird<Core>;
    /**
     * Closes the active database connection
     * @type {Promise}
     */
    close(): Bluebird<Core>;
    /**
     * Provides an express middleware which can be used to set the req.db property
     * to the current Iridium instance.
     * @returns {Iridium.ExpressMiddleware}
     */
    express(): ExpressMiddleware.ExpressMiddleware;
    /**
     * A method which is called whenever a new connection is made to the database.
     *
     * @param connection The underlying MongoDB connection which was created, you can modify or replace this if you wish.
     * @returns A promise for the connection, allowing you to perform any asynchronous initialization required by your application.
     *
     * In subclassed Iridium Cores this method can be overridden to manipulate the properties
     * of the underlying MongoDB connection object, such as authenticating. Until this method
     * resolves a connection object, Iridium will be unable to execute any queries. If you wish
     * to run Iridium queries then look at the onConnected method.
     */
    protected onConnecting(connection: MongoDB.Db): Bluebird<MongoDB.Db>;
    /**
     * A method which is called once a database connection has been established and accepted by Iridium
     *
     * In subclassed Iridium cores this method can be overridden to perform tasks whenever a
     * connection to the database has been established - such as setting up indexes for your
     * collections or seeding the database.
     */
    protected onConnected(): Bluebird<void>;
}
}
declare module 'iridium/dist/lib/Core' {
export * from '~iridium/dist/lib/Core';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Cursor.d.ts
declare module '~iridium/dist/lib/Cursor' {
import { Model } from '~iridium/dist/lib/Model';
import * as General from '~iridium/dist/lib/General';
import * as MongoDB from '~iridium~mongodb';
import * as Bluebird from '~iridium~bluebird';
import * as Index from '~iridium/dist/lib/Index';
/**
 * An Iridium collection cursor which allows the itteration through documents
 * in the collection, automatically wrapping them in the correct instance type.
 *
 * @param TDocument The interface representing the collection's documents
 * @param TInstance The interface or class used to represent the wrapped documents.
 */
export class Cursor<TDocument extends {
    _id?: any;
}, TInstance> {
    private model;
    private conditions;
    cursor: MongoDB.Cursor;
    /**
     * Creates a new Iridium cursor which wraps a MongoDB cursor object
     * @param {Model} model The Iridium model that this cursor belongs to
     * @param {Object} conditions The conditions that resulte in this cursor being created
     * @param {MongoDB.Cursor} cursor The MongoDB native cursor object to be wrapped
     * @constructor
     */
    constructor(model: Model<TDocument, TInstance>, conditions: any, cursor: MongoDB.Cursor);
    /**
     * Counts the number of documents which are matched by this cursor
     * @param {function(Error, Number)} callback A callback which is triggered when the result is available
     * @return {Promise<number>} A promise which will resolve with the number of documents matched by this cursor
     */
    count(callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Runs the specified handler over each instance in the query results
     * @param {function(Instance)} handler The handler which is triggered for each element in the query
     * @param {function(Error)} callback A callback which is triggered when all operations have been dispatched
     * @return {Promise} A promise which is resolved when all operations have been dispatched
     */
    forEach(handler: (instance: TInstance) => void, callback?: General.Callback<void>): Bluebird<void>;
    /**
     * Runs the specified transform over each instance in the query results and returns the resulting transformed objects
     * @param {function(Instance): TResult} transform A handler which is used to transform the result objects
     * @param {function(Error, TResult[])} callback A callback which is triggered when the transformations are completed
     * @return {Promise<TResult[]>} A promise which is fulfilled with the results of the transformations
     */
    map<TResult>(transform: (instance: TInstance) => TResult | Bluebird<TResult>, callback?: General.Callback<TResult[]>): Bluebird<TResult[]>;
    /**
     * Retrieves all matching instances and returns them in an array
     * @param {function(Error, TInstance[])} callback A callback which is triggered with the resulting instances
     * @return {Promise<TInstance[]>} A promise which resolves with the instances returned by the query
     */
    toArray(callback?: General.Callback<TInstance[]>): Bluebird<TInstance[]>;
    /**
     * Retrieves the next item in the results list
     * @param {function(Error, TInstance)} callback A callback which is triggered when the next item becomes available
     * @return {Promise<TInstance>} A promise which is resolved with the next item
     */
    next(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves the next item in the result list and then closes the cursor
     * @param {function(Error, TInstance)} callback A callback which is triggered when the next item becomes available
     * @return {Promise<TInstance>} A promise which is resolved once the item becomes available and the cursor has been closed.
     */
    one(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Returns a new cursor which behaves the same as this one did before any results were retrieved
     * @return {Cursor} The new cursor which starts at the beginning of the results
     */
    rewind(): Cursor<TDocument, TInstance>;
    /**
     * Returns a new cursor which sorts its results by the given index expression
     * @param {model.IndexSpecification} sortExpression The index expression dictating the sort order and direction to use
     * @return {Cursor} The new cursor which sorts its results by the sortExpression
     */
    sort(sortExpression: Index.IndexSpecification): Cursor<TDocument, TInstance>;
    /**
     * Returns a new cursor which limits the number of returned results
     * @param {Number} limit The maximum number of results to return
     * @return {Cursor} The new cursor which will return a maximum number of results
     */
    limit(limit: number): Cursor<TDocument, TInstance>;
    /**
     * Returns a new cursor which skips a number of results before it begins
     * returning any.
     * @param {Number} skip The number of results to skip before the cursor beings returning
     * @return {Cursor} The new cursor which skips a number of results
     */
    skip(skip: number): Cursor<TDocument, TInstance>;
    /**
     * Returns a new cursor which will read from the specified node type.
     * @param {String} type The type of node to read from - see https://docs.mongodb.org/manual/core/read-preference/
     * @return {Cursor} The new cursor which reads from the specified node type
     */
    readFrom(type: string): Cursor<TDocument, TInstance>;
}
}
declare module 'iridium/dist/lib/Cursor' {
export * from '~iridium/dist/lib/Cursor';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/ModelCache.d.ts
declare module '~iridium/dist/lib/ModelCache' {
import { Model } from '~iridium/dist/lib/Model';
import * as Bluebird from '~iridium~bluebird';
/**
 * A centralized class which ties the cache and cache directors together in a cohesive way
 * for use by Iridium.
 * @internal
 */
export class ModelCache {
    model: Model<any, any>;
    constructor(model: Model<any, any>);
    set<T>(value: T): void;
    get<T>(conditions: any): Bluebird<T>;
    clear(conditions: any): void;
}
}
declare module 'iridium/dist/lib/ModelCache' {
export * from '~iridium/dist/lib/ModelCache';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/ModelHelpers.d.ts
declare module '~iridium/dist/lib/ModelHelpers' {
import { Model } from '~iridium/dist/lib/Model';
import * as Skmatc from '~iridium~skmatc';
/**
 * A number of helper methods used commonly within Iridium, they provide a means to transform,
 * validate, wrap and diff instances and documents. By keeping these methods in one place we
 * help to improve testability and reduce code duplication (mouse abuse) throughout the codebase.
 * @internal
 */
export class ModelHelpers<TDocument extends {
    _id?: any;
}, TInstance> {
    model: Model<TDocument, TInstance>;
    constructor(model: Model<TDocument, TInstance>);
    private _validator;
    /**
     * Validates a document to ensure that it matches the model's ISchema requirements
     * @param {any} document The document to validate against the ISchema
     * @returns {SkmatcCore.IResult} The result of the validation
     */
    validate(document: TDocument): Skmatc.Result;
    /**
     * Wraps the given document in an instance wrapper for use throughout the application
     * @param {any} document The document to be wrapped as an instance
     * @param {Boolean} isNew Whether the instance originated from the database or was created by the application
     * @param {Boolean} isPartial Whether the document supplied contains all information present in the database
     * @returns {any} An instance which wraps this document
     */
    wrapDocument(document: TDocument, isNew?: boolean, isPartial?: boolean): TInstance;
    /**
     * Converts the given document to its database form into a form
     * using the transforms defined on the model.
     * @param {any} document The document to be converted
     * @returns {any} The result of having transformed the document.
     * @remarks This is only really called from insert/create - as
     */
    transformToDB<T>(document: T, options?: TransformOptions): T;
    /**
     * Converts the given document from its database form using the
     * transforms defined on the model.
     * @param document The document to be converted.
     * @returns The result of having transformed the document.
     * @remarks Unlike the transformToDB function - this method only applies
     * document level transforms, as property level transforms are applied in
     * their relevant instance setters.
     */
    transformFromDB(document: TDocument, options?: TransformOptions): TDocument;
    /**
     * Converts the given document to its database form into a form
     * using the transforms defined on the model.
     * @param document The document to be converted
     * @param processProperties Whether or not to process properties in addition
     * document level transforms.
     * @returns {any} A new document cloned from the original and transformed
     */
    convertToDB<T>(document: T, options?: TransformOptions): T;
    /**
     * Performs a diff operation between two documents and creates a MongoDB changes object to represent the differences
     * @param {any} original The original document prior to changes being made
     * @param {any} modified The document after changes were made
     */
    diff(original: TDocument, modified: TDocument): any;
    /**
     * Clones the given document recursively, taking into account complex types like
     * Buffers correctly.
     *
     * @param {any} The document you wish to clone deeply.
     */
    cloneDocument<T>(original: T): T;
    /**
     * Clones the given document recursively, taking into account complex types like
     * Buffers correctly. Optimized for working with query documents instead of true
     * documents.
     *
     * @param {any} The document you wish to clone deeply.
     */
    cloneConditions<T>(original: T): T;
}
export interface TransformOptions {
    properties?: boolean;
    document?: boolean;
}
}
declare module 'iridium/dist/lib/ModelHelpers' {
export * from '~iridium/dist/lib/ModelHelpers';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/ModelHandlers.d.ts
declare module '~iridium/dist/lib/ModelHandlers' {
import { Model } from '~iridium/dist/lib/Model';
import * as ModelOptions from '~iridium/dist/lib/ModelOptions';
import * as Bluebird from '~iridium~bluebird';
/**
 * Provides a number of methods which are used to handle events that occur within
 * the Iridium workflow - such as what happens when a document is received from
 * the database, or how to handle the creation of new documents and saving of instances.
 *
 * Mostly this is for cache support, wrapping and hook triggering.
 * @internal
 */
export class ModelHandlers<TDocument extends {
    _id?: any;
}, TInstance> {
    model: Model<TDocument, TInstance>;
    constructor(model: Model<TDocument, TInstance>);
    documentReceived<TResult>(conditions: any, result: TDocument, wrapper: (document: TDocument, isNew?: boolean, isPartial?: boolean) => TResult, options?: ModelOptions.QueryOptions): Bluebird<TResult>;
    creatingDocuments(documents: TDocument[]): Bluebird<any[]>;
    savingDocument(instance: TInstance, changes: any): Bluebird<TInstance>;
}
}
declare module 'iridium/dist/lib/ModelHandlers' {
export * from '~iridium/dist/lib/ModelHandlers';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/ModelInterfaces.d.ts
declare module '~iridium/dist/lib/ModelInterfaces' {
/**
 * The interface to which a prepared instance constructor should conform. When called with a document
 * object, it should instantiate a new instance of type TInstance which is associated with its parent
 * model.
 *
 * This is primarily used internally for prepared model instance constructors.
 *
 * @param TDocument The interface used to describe the structure of the documents found in the database collection.
 * @param TInstance The interface or class used to wrap the documents returned from the database.
 *
 * @internal
 */
export interface ModelSpecificInstanceConstructor<TDocument extends {
    _id?: any;
}, TInstance> {
    new (doc: TDocument, isNew?: boolean, isPartial?: boolean): TInstance;
}
}
declare module 'iridium/dist/lib/ModelInterfaces' {
export * from '~iridium/dist/lib/ModelInterfaces';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Aggregate.d.ts
declare module '~iridium/dist/lib/Aggregate' {
export interface Stage {
}
}
declare module 'iridium/dist/lib/Aggregate' {
export * from '~iridium/dist/lib/Aggregate';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Model.d.ts
declare module '~iridium/dist/lib/Model' {
import * as MongoDB from '~iridium~mongodb';
import * as Bluebird from '~iridium~bluebird';
import * as Skmatc from '~iridium~skmatc';
import { Core } from '~iridium/dist/lib/Core';
import { Schema } from '~iridium/dist/lib/Schema';
import { Hooks } from '~iridium/dist/lib/Hooks';
import { CacheDirector } from '~iridium/dist/lib/CacheDirector';
import * as General from '~iridium/dist/lib/General';
import { Cursor } from '~iridium/dist/lib/Cursor';
import * as Index from '~iridium/dist/lib/Index';
import * as ModelOptions from '~iridium/dist/lib/ModelOptions';
import { ModelCache } from '~iridium/dist/lib/ModelCache';
import { ModelHelpers } from '~iridium/dist/lib/ModelHelpers';
import { ModelHandlers } from '~iridium/dist/lib/ModelHandlers';
import * as ModelInterfaces from '~iridium/dist/lib/ModelInterfaces';
import { InstanceImplementation } from '~iridium/dist/lib/InstanceInterface';
import { Transforms } from '~iridium/dist/lib/Transforms';
import * as AggregationPipeline from '~iridium/dist/lib/Aggregate';
/**
 * An Iridium Model which represents a structured MongoDB collection.
 * Models expose the methods you will generally use to query those collections, and ensure that
 * the results of those queries are returned as {TInstance} instances.
 *
 * @param TDocument The interface used to determine the schema of documents in the collection.
 * @param TInstance The interface or class used to represent collection documents in the JS world.
 *
 * @class
 */
export class Model<TDocument extends {
    _id?: any;
}, TInstance> {
    /**
     * Creates a new Iridium model representing a given ISchema and backed by a collection whose name is specified
     * @param core The Iridium core that this model should use for database access
     * @param instanceType The class which will be instantiated for each document retrieved from the database
     * @constructor
     */
    constructor(core: Core, instanceType: InstanceImplementation<TDocument, TInstance>);
    /**
     * Loads any externally available properties (generally accessed using public getters/setters).
     */
    private loadExternal(instanceType);
    /**
     * Loads any internally (protected/private) properties and helpers only used within Iridium itself.
     */
    private loadInternal();
    /**
     * Process any callbacks and plugin delegation for the creation of this model.
     * It will generally be called whenever a new Iridium Core is created, however is
     * more specifically tied to the lifespan of the models themselves.
     */
    private onNewModel();
    private _helpers;
    /**
     * Provides helper methods used by Iridium for common tasks
     * @returns A set of helper methods which are used within Iridium for common tasks
     */
    helpers: ModelHelpers<TDocument, TInstance>;
    private _handlers;
    /**
     * Provides helper methods used by Iridium for hook delegation and common processes
     * @returns A set of helper methods which perform common event and response handling tasks within Iridium.
     */
    handlers: ModelHandlers<TDocument, TInstance>;
    private _hooks;
    /**
     * Gets the even hooks subscribed on this model for a number of different state changes.
     * These hooks are primarily intended to allow lifecycle manipulation logic to be added
     * in the user's model definition, allowing tasks such as the setting of default values
     * or automatic client-side joins to take place.
     */
    hooks: Hooks<TDocument, TInstance>;
    private _schema;
    /**
     * Gets the schema dictating the data structure represented by this model.
     * The schema is used by skmatc to validate documents before saving to the database, however
     * until MongoDB 3.1 becomes widely available (with server side validation support) we are
     * limited in our ability to validate certain types of updates. As such, these validations
     * act more as a data-integrity check than anything else, unless you purely make use of Omnom
     * updates within instances.
     * @public
     * @returns The defined validation schema for this model
     */
    schema: Schema;
    private _core;
    /**
     * Gets the Iridium core that this model is associated with.
     * @public
     * @returns The Iridium core that this model is bound to
     */
    core: Core;
    private _collection;
    /**
     * Gets the underlying MongoDB collection from which this model's documents are retrieved.
     * You can make use of this object if you require any low level access to the MongoDB collection,
     * however we recommend you make use of the Iridium methods whereever possible, as we cannot
     * guarantee the accuracy of the type definitions for the underlying MongoDB driver.
     * @public
     * @returns {Collection}
     */
    collection: MongoDB.Collection;
    /**
     * Gets the name of the underlying MongoDB collection from which this model's documents are retrieved
     * @public
     */
    /**
     * Sets the name of the underlying MongoDB collection from which this model's documents are retrieved
     * @public
     */
    collectionName: string;
    private _cacheDirector;
    /**
     * Gets the cache controller which dictates which queries will be cached, and under which key
     * @public
     * @returns {CacheDirector}
     */
    cacheDirector: CacheDirector;
    private _cache;
    /**
     * Gets the cache responsible for storing objects for quick retrieval under certain conditions
     * @public
     * @returns {ModelCache}
     */
    cache: ModelCache;
    private _Instance;
    /**
     * Gets the constructor responsible for creating instances for this model
     */
    Instance: ModelInterfaces.ModelSpecificInstanceConstructor<TDocument, TInstance>;
    private _transforms;
    /**
     * Gets the transforms which are applied whenever a document is received from the database, or
     * prior to storing a document in the database. Tasks such as converting an ObjectID to a string
     * and vice versa are all listed in this object.
     */
    transforms: Transforms;
    private _validators;
    /**
     * Gets the custom validation types available for this model. These validators are added to the
     * default skmatc validators, as well as those available through plugins, for use when checking
     * your instances.
     */
    validators: Skmatc.Validator[];
    private _indexes;
    /**
     * Gets the indexes which Iridium will manage on this model's database collection.
     */
    indexes: (Index.Index | Index.IndexSpecification)[];
    /**
     * Retrieves all documents in the collection and wraps them as instances
     * @param {function(Error, TInstance[])} callback An optional callback which will be triggered when results are available
     * @returns {Promise<TInstance[]>}
     */
    find(): Cursor<TDocument, TInstance>;
    /**
     * Returns all documents in the collection which match the conditions and wraps them as instances
     * @param {Object} conditions The MongoDB query dictating which documents to return
     * @returns {Promise<TInstance[]>}
     */
    find(conditions: {
        _id?: any;
        [key: string]: any;
    } | any): Cursor<TDocument, TInstance>;
    /**
     * Returns all documents in the collection which match the conditions
     * @param {Object} conditions The MongoDB query dictating which documents to return
     * @param {Object} fields The fields to include or exclude from the document
     * @returns {Promise<TInstance[]>}
     */
    find(conditions: {
        _id?: any;
        [key: string]: any;
    } | any, fields: {
        [name: string]: number;
    }): Cursor<TDocument, TInstance>;
    /**
     * Retrieves a single document from the collection and wraps it as an instance
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    get(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection with the given ID and wraps it as an instance
     * @param {any} id The document's unique _id field value in downstream format
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    get(id: any, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection which matches the conditions
     * @param {Object} conditions The MongoDB query dictating which document to return
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    get(conditions: {
        _id?: any;
        [key: string]: any;
    }, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection with the given ID and wraps it as an instance
     * @param {any} id The document's unique _id field value in downstream format
     * @param {QueryOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    get(id: any, options: ModelOptions.QueryOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection which matches the conditions
     * @param {Object} conditions The MongoDB query dictating which document to return
     * @param {QueryOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    get(conditions: {
        _id?: any;
        [key: string]: any;
    }, options: ModelOptions.QueryOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection and wraps it as an instance
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    findOne(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection with the given ID and wraps it as an instance
     * @param {any} id The document's unique _id field value in downstream format
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    findOne(id: any, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection which matches the conditions
     * @param {Object} conditions The MongoDB query dictating which document to return
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    findOne(conditions: {
        _id?: any;
        [key: string]: any;
    }, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection with the given ID and wraps it as an instance
     * @param {any} id The document's unique _id field value in downstream format
     * @param {QueryOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    findOne(id: any, options: ModelOptions.QueryOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves a single document from the collection which matches the conditions
     * @param {Object} conditions The MongoDB query dictating which document to return
     * @param {QueryOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback An optional callback which will be triggered when a result is available
     * @returns {Promise<TInstance>}
     */
    findOne(conditions: {
        _id?: any;
        [key: string]: any;
    }, options: ModelOptions.QueryOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Inserts an object into the collection after validating it against this model's schema
     * @param {Object} object The object to insert into the collection
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    create(objects: TDocument, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Inserts an object into the collection after validating it against this model's schema
     * @param {Object} object The object to insert into the collection
     * @param {CreateOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    create(objects: TDocument, options: ModelOptions.CreateOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Inserts the objects into the collection after validating them against this model's schema
     * @param {Object[]} objects The objects to insert into the collection
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    create(objects: TDocument[], callback?: General.Callback<TInstance[]>): Bluebird<TInstance[]>;
    /**
     * Inserts the objects into the collection after validating them against this model's schema
     * @param {Object[]} objects The objects to insert into the collection
     * @param {CreateOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    create(objects: TDocument[], options: ModelOptions.CreateOptions, callback?: General.Callback<TInstance[]>): Bluebird<TInstance[]>;
    /**
     * Inserts an object into the collection after validating it against this model's schema
     * @param {Object} object The object to insert into the collection
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    insert(objects: TDocument, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Inserts an object into the collection after validating it against this model's schema
     * @param {Object} object The object to insert into the collection
     * @param {CreateOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    insert(objects: TDocument, options: ModelOptions.CreateOptions, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Inserts the objects into the collection after validating them against this model's schema
     * @param {Object[]} objects The objects to insert into the collection
     * @param {function(Error, TInstance[])} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    insert(objects: TDocument[], callback?: General.Callback<TInstance[]>): Bluebird<TInstance[]>;
    /**
     * Inserts the objects into the collection after validating them against this model's schema
     * @param {Object[]} objects The objects to insert into the collection
     * @param {CreateOptions} options The options dictating how this function behaves
     * @param {function(Error, TInstance[])} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    insert(objects: TDocument[], options: ModelOptions.CreateOptions, callback?: General.Callback<TInstance[]>): Bluebird<TInstance[]>;
    /**
     * Updates the documents in the backing collection which match the conditions using the given update instructions
     * @param {Object} conditions The conditions which determine which documents will be updated
     * @param {Object} changes The changes to make to the documents
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     */
    update(conditions: {
        _id?: any;
        [key: string]: any;
    } | any, changes: any, callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Updates the documents in the backing collection which match the conditions using the given update instructions
     * @param {Object} conditions The conditions which determine which documents will be updated
     * @param {Object} changes The changes to make to the documents
     * @param {UpdateOptions} options The options which dictate how this function behaves
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     */
    update(conditions: {
        _id?: any;
        [key: string]: any;
    } | any, changes: any, options: ModelOptions.UpdateOptions, callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Counts the number of documents in the collection
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     * @returns {Promise<number>}
     */
    count(callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Counts the number of documents in the collection which match the conditions provided
     * @param {Object} conditions The conditions which determine whether an object is counted or not
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     * @returns {Promise<number>}
     */
    count(conditions: {
        _id?: any;
        [key: string]: any;
    } | any, callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Removes all documents from the collection
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     * @returns {Promise<number>}
     */
    remove(callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Removes all documents from the collection which match the conditions
     * @param {Object} conditions The conditions determining whether an object is removed or not
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     * @returns {Promise<number>}
     */
    remove(conditions: {
        _id?: any;
        [key: string]: any;
    } | any, callback?: General.Callback<number>): Bluebird<number>;
    /**
     * Removes all documents from the collection which match the conditions
     * @param {Object} conditions The conditions determining whether an object is removed or not
     * @param {Object} options The options controlling the way in which the function behaves
     * @param {function(Error, Number)} callback A callback which is triggered when the operation completes
     * @returns {Promise<number>}
     */
    remove(conditions: {
        _id?: any;
        [key: string]: any;
    }, options: ModelOptions.RemoveOptions, callback?: General.Callback<number>): Bluebird<number>;
    aggregate<T>(pipeline: AggregationPipeline.Stage[]): Bluebird<T[]>;
    /**
     * Ensures that the given index is created for the collection
     * @param {Object} specification The index specification object used by MongoDB
     * @param {function(Error, String)} callback A callback which is triggered when the operation completes
     * @returns {Promise<String>} The name of the index
     */
    ensureIndex(specification: Index.IndexSpecification, callback?: General.Callback<string>): Bluebird<string>;
    /**
     * Ensures that the given index is created for the collection
     * @param {Object} specification The index specification object used by MongoDB
     * @param {MongoDB.IndexOptions} options The options dictating how the index is created and behaves
     * @param {function(Error, String)} callback A callback which is triggered when the operation completes
     * @returns {Promise<String>} The name of the index
     */
    ensureIndex(specification: Index.IndexSpecification, options: MongoDB.IndexOptions, callback?: General.Callback<string>): Bluebird<string>;
    /**
     * Ensures that all indexes defined in the model's options are created
     * @param {function(Error, String[])} callback A callback which is triggered when the operation completes
     * @returns {Promise<String[]>} The names of the indexes
     */
    ensureIndexes(callback?: General.Callback<string[]>): Bluebird<string[]>;
    /**
     * Drops the index with the specified name if it exists in the collection
     * @param {String} name The name of the index to remove
     * @param {function(Error, Boolean)} callback A callback which is triggered when the operation completes
     * @returns {Promise<Boolean>} Whether the index was dropped
     */
    dropIndex(name: string, callback?: General.Callback<boolean>): Bluebird<boolean>;
    /**
     * Drops the index if it exists in the collection
     * @param {IndexSpecification} index The index to remove
     * @param {function(Error, Boolean)} callback A callback which is triggered when the operation completes
     * @returns {Promise<Boolean>} Whether the index was dropped
     */
    dropIndex(index: Index.IndexSpecification, callback?: General.Callback<boolean>): Bluebird<boolean>;
    /**
     * Removes all indexes (except for _id) from the collection
     * @param {function(Error, Boolean)} callback A callback which is triggered when the operation completes
     * @returns {Promise<Boolean>} Whether the indexes were dropped
     */
    dropIndexes(callback?: General.Callback<boolean>): Bluebird<boolean>;
}
}
declare module 'iridium/dist/lib/Model' {
export * from '~iridium/dist/lib/Model';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/General.d.ts
declare module '~iridium/dist/lib/General' {
/**
 * A method which is called once an asynchronous operation has completed, an alternative
 * to using Promises.
 * @param T The type of object returned by the asynchronous operation.
 */
export interface Callback<T> {
    /**
     * @param err The error object, if one occurred, otherwise null if the operation completed successfully.
     * @param object The result of the asynchronous operation if it completed successfully. If err is defined, the presence of this value is unknown.
     */
    (err: Error, object?: T): void;
}
/**
 * A method which is used to determine whether a value within a collection meets a set of criteria.
 * @param T The type of item in the collection.
 */
export interface Predicate<T> {
    /**
     * @param object The value of the item in the collection
     * @param key The key, if one is available, under which the item appeared within the collection
     * @returns A true-y value if the item met the predicate conditions, false-y values if it did not.
     */
    (object: T, key?: string): boolean;
}
/**
 * A method which is called to retrieve a value of the given type.
 * @param T The type of value to be retrieved.
 */
export interface PropertyGetter<T> {
    /**
     * Gets the current value of the property
     * @returns The current value
     */
    (): T;
}
/**
 * A method which is called to set a value of the given type.
 * @param T The type of value to set
 */
export interface PropertySetter<T> {
    /**
     * Sets the value to the provided one
     * @param value The new value to set
     */
    (value: T): void;
}
/**
 * A compound property which provides either a getter, setter or both.
 * @param T The type of objects stored in the property
 */
export interface Property<T> {
    /**
     * An optional getter which can be used to retrieve the property's value
     */
    get?: PropertyGetter<T>;
    /**
     * An optional setter which can be used to set the property's value
     */
    set?: PropertySetter<T>;
}
}
declare module 'iridium/dist/lib/General' {
export * from '~iridium/dist/lib/General';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Index.d.ts
declare module '~iridium/dist/lib/Index' {
import * as MongoDB from '~iridium~mongodb';
export interface Index {
    spec: IndexSpecification;
    options?: MongoDB.IndexOptions;
}
export interface IndexSpecification {
    [key: string]: number | string;
}
}
declare module 'iridium/dist/lib/Index' {
export * from '~iridium/dist/lib/Index';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/skmatc/master/index.d.ts
declare module '~iridium~skmatc/index' {
export function scope(schema: any): Skmatc;

export var validators: Validator[];
export function create(handles: (schema: any) => boolean, validate: (schema: any, data: any, path: string) => Result, options?: { name?: string }): Validator;
export function validate(validators: Validator[], schema: any, data: any, path?: string): Result;
export function register(validator: Validator);

export class Skmatc {
	schema: any;
	validators: Validator[];
	validate(data: any, path?: string): Result;
	register(validator: Validator);
}

export class Validator {
	constructor(skmatc: Skmatc, options?: any);
	static create(handles: (schema: any) => boolean, validate: (schema: any, data: any, path: string) => Result, options?: { name?: string }): Validator;
	static module(handles: (schema: any) => boolean, validate: (schema: any, data: any, path: string) => Result, options?: { name?: string }): Validator;

	name: string;
	skmatc: Skmatc;
	handles(schema: any): boolean;
	validate(schema: any, data: any, path: string): Result;
	assert(schema: any, data: any, path: string, test: boolean, message?: string): Result;
	fail(schema: any, data: any, path: string, message?: string): Result;
}

export class Result {
	constructor(failures: Failure[]);
	static compound(results: Result[]): Result;

	failures: Failure[];
	success: boolean;
	failed: boolean;
	message: string;
	messages: string[];
	error: Error;
}

export class Failure {
	constructor(validator: Validator, schema: any, data: any, path: string, message?: string);
	validator: Validator;
	schema: any;
	data: any;
	path: string;
	message: string;
}

export interface IValidationHandler {
	(thisArg: {
		validator: IValidationHandler;
		skmatc: Skmatc;
		fail(message?: string);
		assert(test: boolean, message?: string);
	}, schema: any, data: any, path: string): Result;
}
}
declare module '~iridium~skmatc' {
export * from '~iridium~skmatc/index';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Instance.d.ts
declare module '~iridium/dist/lib/Instance' {
import { Model } from '~iridium/dist/lib/Model';
import { CacheDirector } from '~iridium/dist/lib/CacheDirector';
import * as General from '~iridium/dist/lib/General';
import * as Index from '~iridium/dist/lib/Index';
import { Schema } from '~iridium/dist/lib/Schema';
import { Transforms } from '~iridium/dist/lib/Transforms';
import * as Bluebird from '~iridium~bluebird';
import * as Skmatc from '~iridium~skmatc';
/**
 * The default Iridium Instance implementation which provides methods for saving, refreshing and
 * removing the wrapped document from the collection, as well as integrating with Omnom, our
 * built in document diff processor which allows clean, atomic, document updates to be performed
 * without needing to write the update queries yourself.
 *
 * @param TDocument The interface representing the structure of the documents in the collection.
 * @param TInstance The type of instance which wraps the documents, generally the subclass of this class.
 *
 * This class will be subclassed automatically by Iridium to create a model specific instance
 * which takes advantage of some of v8's optimizations to boost performance significantly.
 * The instance returned by the model, and all of this instance's methods, will be of type
 * TInstance - which should represent the merger of TSchema and IInstance for best results.
 */
export class Instance<TDocument extends {
    _id?: any;
}, TInstance> {
    /**
     * Creates a new instance which represents the given document as a type of model
     * @param model The model that dictates the collection the document originated from as well as how validations are performed.
     * @param document The document which should be wrapped by this instance
     * @param isNew Whether the document is new (doesn't exist in the database) or not
     * @param isPartial Whether the document has only a subset of its fields populated
     *
     */
    constructor(model: Model<TDocument, TInstance>, document: TDocument, isNew?: boolean, isPartial?: boolean);
    private _isNew;
    private _isPartial;
    private _model;
    private _original;
    private _modified;
    /**
     * Gets the underlying document representation of this instance
     */
    document: TDocument;
    [name: string]: any;
    /**
     * A function which is called whenever a new document is in the process of being inserted into the database.
     * @param document The document which will be inserted into the database.
     */
    static onCreating: (document: {
        _id?: any;
    }) => Promise<any> | void;
    /**
     * A function which is called whenever a document of this type is received from the database, prior to it being
     * wrapped by an Instance object.
     * @param document The document that was retrieved from the database.
     */
    static onRetrieved: (document: {
        _id?: any;
    }) => Promise<any> | void;
    /**
     * A function which is called whenever a new instance has been created to wrap a document.
     * @param instance The instance which has been created.
     */
    static onReady: (instance: Instance<{
        _id?: any;
    }, Instance<{
        _id?: any;
    }, any>>) => Promise<any> | void;
    /**
     * A function which is called whenever an instance's save() method is called to allow you to interrogate and/or manipulate
     * the changes which are being made.
     *
     * @param instance The instance to which the changes are being made
     * @param changes The MongoDB change object describing the changes being made to the document.
     */
    static onSaving: (instance: Instance<{
        _id?: any;
    }, Instance<{
        _id?: any;
    }, any>>, changes: any) => Promise<any> | void;
    /**
     * The name of the collection into which documents of this type are stored.
     */
    static collection: string;
    /**
     * The schema used to validate documents of this type before being stored in the database.
     */
    static schema: Schema;
    /**
     * Additional which should be made available for use in the schema definition for this instance.
     */
    static validators: Skmatc.Validator[];
    /**
     * The transformations which should be applied to properties of documents of this type.
     */
    static transforms: Transforms;
    /**
     * The cache director used to derive unique cache keys for documents of this type.
     */
    static cache: CacheDirector;
    /**
     * The indexes which should be managed by Iridium for the collection used by this type.
     */
    static indexes: (Index.Index | Index.IndexSpecification)[];
    /**
     * Saves any changes to this instance, using the built in diff algorithm to write the update query.
     * @param {function(Error, IInstance)} callback A callback which is triggered when the save operation completes
     * @returns {Promise<TInstance>}
     */
    save(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Saves the given changes to this instance and updates the instance to match the latest database document.
     * @param {Object} changes The MongoDB changes object to be used when updating this instance
     * @param {function(Error, IInstance)} callback A callback which is triggered when the save operation completes
     * @returns {Promise<TInstance>}
     */
    save(changes: Object, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Saves the given changes to this instance and updates the instance to match the latest database document.
     * @param {Object} conditions The conditions under which the update will take place - these will be merged with an _id query
     * @param {Object} changes The MongoDB changes object to be used when updating this instance
     * @param {function(Error, IInstance)} callback A callback which is triggered when the save operation completes
     * @returns {Promise<TInstance>}
     */
    save(conditions: Object, changes: Object, callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Updates this instance to match the latest document available in the backing collection
     * @param {function(Error, IInstance)} callback A callback which is triggered when the update completes
     * @returns {Promise<TInstance>}
     */
    update(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Updates this instance to match the latest document available in the backing collection
     * @param {function(Error, IInstance)} callback A callback which is triggered when the update completes
     * @returns {Promise<TInstance>}
     */
    refresh(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Removes this instance's document from the backing collection
     * @param {function(Error, IInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    delete(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Removes this instance's document from the backing collection
     * @param {function(Error, IInstance)} callback A callback which is triggered when the operation completes
     * @returns {Promise<TInstance>}
     */
    remove(callback?: General.Callback<TInstance>): Bluebird<TInstance>;
    /**
     * Retrieves the first element in an enumerable collection which matches the predicate
     * @param collection The collection from which to retrieve the element
     * @param predicate The function which determines whether to select an element
     * @returns The first element in the array which matched the predicate.
     */
    first<T>(collection: T[], predicate: General.Predicate<T>): T;
    /**
     * Retrieves the first element in an enumerable collection which matches the predicate
     * @param collection The collection from which to retrieve the element
     * @param predicate The function which determines whether to select an element
     * @returns The first element in the object which matched the predicate.
     */
    first<T>(collection: {
        [key: string]: T;
    }, predicate: General.Predicate<T>): T;
    /**
     * Retrieves a number of elements from an enumerable collection which match the predicate
     * @param collection The collection from which elements will be plucked
     * @param predicate The function which determines the elements to be plucked
     * @returns A new array containing the elements in the array which matched the predicate.
     */
    select<T>(collection: T[], predicate: General.Predicate<T>): T[];
    /**
     * Retrieves a number of elements from an enumerable collection which match the predicate
     * @param collection The collection from which elements will be plucked
     * @param predicate The function which determines the elements to be plucked
     * @returns An object with the properties from the collection which matched the predicate.
     */
    select<T>(collection: {
        [key: string]: T;
    }, predicate: General.Predicate<T>): {
        [key: string]: T;
    };
    /**
     * Gets the JSON representation of this instance
     * @returns {TDocument}
     */
    toJSON(): any;
    /**
     * Gets a string representation of this instance
     * @returns {String}
     */
    toString(): string;
}
}
declare module 'iridium/dist/lib/Instance' {
export * from '~iridium/dist/lib/Instance';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/InstanceInterface.d.ts
declare module '~iridium/dist/lib/InstanceInterface' {
import * as Skmatc from '~iridium~skmatc';
import { Schema } from '~iridium/dist/lib/Schema';
import { Model } from '~iridium/dist/lib/Model';
import * as Index from '~iridium/dist/lib/Index';
import { CacheDirector } from '~iridium/dist/lib/CacheDirector';
import { Transforms } from '~iridium/dist/lib/Transforms';
/**
 * This interface dictates the format of an instance class which wraps documents received
 * from the database for a specific Iridium model.
 *
 * @param TDocument The interface representing the documents stored in the database, after being passed through the transforms pipeline.
 * @param TInstance The type of object which is instantiated when calling this implementation's constructor.
 *
 * It is important to note that, when implementing this interface, each of the properties and methods
 * should be exposed statically. That is, you would expose the collection property as a static variable
 * on the instance implementation, since prototype methods and variables become available to consumers of the
 * instance itself.
 */
export interface InstanceImplementation<TDocument extends {
    _id?: any;
}, TInstance> {
    /**
     * A constructor which creates a new instance tied to the given model and representing the given document.
     * @param model The Iridium Model which this instance should be tied to, gives the instance access to the database collection and any other context it requires.
     * @param doc The document this instance should wrap from the database. This provides the data context for the instance.
     * @param isNew Whether this document is known to exist in the database or not, for example, if the instance was generated from user input and hasn't been saved yet.
     * @param isPartial Whether the document which has been given to this instance had any field restrictions imposed on it during the query, and may therefore only contain partial data.
     */
    new (model: Model<TDocument, TInstance>, doc: TDocument, isNew?: boolean, isPartial?: boolean): TInstance;
    /**
     * The name of the database collection from which documents are retrieved, and to which they are stored.
     */
    collection: string;
    /**
     * The database schematic used for validation of instances prior to storing them in the database.
     * This schematic should follow the guides set out in skmatc's documentation, and is used whenever
     * you insert a new document into the collection or save an instance using the default instance type.
     * Operations like update() (and by extension, save() when using the update operations) cannot be checked
     * by skmatc for consistency and as a result will not have their data validated - be careful when making
     * use of them as a result.
     */
    schema: Schema;
    /**
     * Any additional indexes on the collection which should be managed by Iridium.
     * This field is optional, but if provided allows you to make use of the model's ensureIndexes() method
     * to automatically generate all specified indexes.
     */
    indexes?: (Index.Index | Index.IndexSpecification)[];
    /**
     * An optional method which will be called whenever a document is about to be inserted into the database,
     * allowing you to set default values and do any preprocessing you wish prior to the document being inserted.
     *
     * @param document The document which will be inserted into the database.
     *
     * This method is executed synchronously, however you can perform asynchronous operations by returning a
     * promise which resolves once your task has completed. Be aware that this method is executed for every
     * document inserted into the database. As a result, long running tasks will have a significant impact
     * on the performance of your inserts.
     */
    onCreating?(document: TDocument): Promise<any> | void;
    /**
     * An optional method which is called whenever a new document is received from the model's collection and
     * prior to the document being wrapped, can be used to perform preprocessing if necessary - however we recommend
     * you rather make use of transforms for that task.
     *
     * @param document The document that was retrieved from the database.
     *
     * This method is executed synchronously, however you can perform asynchronous operations by returning a
     * promise which resolves once your task has completed. Be aware that this method is executed for every
     * document retrieved from the database. As a result, long running tasks will have a significant impact
     * on the performance of your queries.
     */
    onRetrieved?(document: TDocument): Promise<any> | void;
    /**
     * An optional method which is called whenever a new document for this model has been wrapped in an instance.
     *
     * @param instance The instance which has been created.
     *
     * This method is executed synchronously, however you can perform asynchronous operations by returning a
     * promise which resolves once your task has completed. Be aware that this method is executed for every
     * document retrieved from the database. As a result, long running tasks will have a significant impact
     * on the performance of your queries.
     */
    onReady?(instance: TInstance): Promise<any> | void;
    /**
     * An optional method which is called prior to saving an instance, it is provided with the instance itself as
     * well as the proposed changes to the instance. This allows you to make additional changes, such as updating
     * a lastChanged property on the document, or abort changes by throwing an error.
     *
     * @param instance The instance to which the changes are being made
     * @param changes The MongoDB change object describing the changes being made to the document.
     *
     * This method is executed synchronously, however you can perform asynchronous operations by returning a
     * promise which resolves once your task has completed. Be aware that this method is executed for every
     * call to save. As a result, long running tasks will have a significant impact on how quickly your save
     * operations are dispatched.
     */
    onSaving?(instance: TInstance, changes: any): Promise<any> | void;
    /**
     * The cache controller used to determine whether a document may be cached, as well as deriving a unique cache
     * key for the document and similarly, for a query. This works in concert with the cache implementation itself
     * to ensure that documents are cached in an intelligent manner. By default this will simply make use of the
     * document's _id field as the cache key - however that behaviour may be modified if you wish to query on other
     * properties instead.
     */
    cache?: CacheDirector;
    /**
     * Any additional validation types you wish to make available for use within this model's database schema. This
     * allows you to validate using conditions otherwise not available within skmatc itself. For more information
     * on implementing a validator, take a look at the skmatc documentation on GitHub.
     */
    validators?: Skmatc.Validator[];
    /**
     * Any transform operations you would like to perform on documents received from the database, or prior to being
     * sent to the database. These may include things such as converting ObjectIDs to strings for the application, and
     * then back to ObjectIDs once they return to the database.
     */
    transforms?: Transforms;
}
}
declare module 'iridium/dist/lib/InstanceInterface' {
export * from '~iridium/dist/lib/InstanceInterface';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Decorators.d.ts
declare module '~iridium/dist/lib/Decorators' {
import * as MongoDB from '~iridium~mongodb';
import Skmatc = require('~iridium~skmatc');
import { Instance } from '~iridium/dist/lib/Instance';
import { Model } from '~iridium/dist/lib/Model';
import { IndexSpecification } from '~iridium/dist/lib/Index';
import { InstanceImplementation } from '~iridium/dist/lib/InstanceInterface';
/**
 * Specifies the name of the collection to which this instance's documents should be sent.
 * @param name The name of the MongoDB collection to store the documents in.
 *
 * This decorator replaces the use of the static collection property on instance implementation
 * classes. If your transpiler does not support decorators then you are free to make use of the
 * property instead.
 */
export function Collection(name: string): (target: InstanceImplementation<any, any>) => void;
/**
 * Specifies a MongoDB collection level index to be managed by Iridium for this instance type.
 * More than one instance of this decorator may be used if you wish to specify multiple indexes.
 * @param spec The formal index specification which defines the properties and ordering used in the index.
 * @param options The options dictating the way in which the index behaves.
 *
 * This decorator replaces the use of the static indexes property on instance implementation
 * classes. If your transpiler does not support decorators then you are free to make use of the
 * property instead.
 */
export function Index(spec: IndexSpecification, options?: MongoDB.IndexOptions): (target: InstanceImplementation<any, any>) => void;
/**
 * Specifies a custom validator to be made available for this collection's schema.
 * More than one instance of this decorator may be used if you wish to specify multiple validators.
 * @param forType The value in the schema which will be delegated to this function for validation.
 * @param validate A function which calls this.assert(condition) to determine whether a schema node is valid or not.
 *
 * This decorator replaces the use of the static validators property on instance implementation
 * classes. If your transpiler does not support decorators then you are free to make use of the
 * property instead.
 */
export function Validate(forType: any, validate: (schema: any, data: any, path: string) => Skmatc.Result): (target: InstanceImplementation<any, any>) => void;
/**
 * Specifies the schema type for the property this decorator is applied to. This can be used to replace the
 * static schema property on your instance. Multiple instances of this decorator can be applied, but no more
 * than one per property.
 *
 * @param asType The schema validation type to make use of for this property
 * @param required Whether this property is required to have a value or not, defaults to true.
 */
export function Property(asType: any, required?: boolean): (target: Instance<any, any>, name: string) => void;
/**
 * Specifies the schema type for a property with the given name on the class this decorator is applied to. This
 * can either compliment or replace the static schema property on your instance class.
 *
 * @param name The name of the property that is being targetted
 * @param asType The schema validation type to make use of for this property
 * @param required Whether this property is required to have a value or not, defaults to true.
 */
export function Property(name: string, asType: any, required?: boolean): (target: InstanceImplementation<any, any>) => void;
/**
 * Specifies a custom transform to be applied to the property this decorator is applied to.
 *
 * @param fromDB The function used to convert values from the database for the application.
 * @param toDB The function used to convert values from the application to the form used in the database.
 *
 * This decorator can either compliment or replace the static transforms property on your instance
 * class, however only one transform can be applied to any property at a time.
 * If your transpiler does not support decorators then you are free to make use of the
 * property instead.
 *
 * If this decorator is applied to the instance class itself, as opposed to a property, then
 * it will be treated as a $document transformer - and will receive the full document as opposed
 * to individual property values. Similarly, it is expected to return a full document when either
 * fromDB or toDB is called.
 */
export function Transform(fromDB: (value: any, property: string, model: Model<any, any>) => any, toDB: (value: any, property: string, model: Model<any, any>) => any): (target: Instance<any, any>, property?: string) => void;
/**
 * Specifies that this property should be treated as an ObjectID, with the requisite validator and transforms.
 *
 * This decorator applies an ObjectID validator to the property, which ensures that values sent to the database
 * are instances of the MongoDB ObjectID type, as well as applying a transform operation which converts ObjectIDs
 * to strings for your application, and then converts strings back to ObjectIDs for the database.
 */
export function ObjectID(target: Instance<any, any>, name: string): void;
/**
 * Specifies that this property should be stored using the MongoDB binary type and represented as a Buffer.
 *
 * This decorator applies a Buffer validator to the property, which ensures that values you send to the database
 * are well formatted Buffer objects represented using the BSON Binary datatype. In addition to this, it will
 * apply a transform which ensures you only work with Buffer objects and that data is always stored in Binary
 * format.
 */
export function Binary(target: Instance<any, any>, name: string): void;
}
declare module 'iridium/dist/lib/Decorators' {
export * from '~iridium/dist/lib/Decorators';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Plugins.d.ts
declare module '~iridium/dist/lib/Plugins' {
import { Model } from '~iridium/dist/lib/Model';
import Skmatc = require('~iridium~skmatc');
export interface Plugin {
    newModel?(model: Model<any, any>): any;
    newInstance?(instance: any, model: Model<any, any>): any;
    validate?: Skmatc.Validator | Skmatc.Validator[];
}
}
declare module 'iridium/dist/lib/Plugins' {
export * from '~iridium/dist/lib/Plugins';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Schema.d.ts
declare module '~iridium/dist/lib/Schema' {
export interface Schema {
    _id: boolean | any;
    [key: string]: any;
}
}
declare module 'iridium/dist/lib/Schema' {
export * from '~iridium/dist/lib/Schema';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Cache.d.ts
declare module '~iridium/dist/lib/Cache' {
export interface Cache {
    set<T>(key: string, value: T): void;
    get<T>(key: string): PromisesAPlus.Thenable<T>;
    clear(key: string): void;
}
}
declare module 'iridium/dist/lib/Cache' {
export * from '~iridium/dist/lib/Cache';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/CacheDirector.d.ts
declare module '~iridium/dist/lib/CacheDirector' {
export interface CacheDirector {
    valid<T>(object: T): boolean;
    buildKey<T>(object: T): string;
    validQuery(conditions: any): boolean;
    buildQueryKey(conditions: any): string;
}
}
declare module 'iridium/dist/lib/CacheDirector' {
export * from '~iridium/dist/lib/CacheDirector';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/ModelOptions.d.ts
declare module '~iridium/dist/lib/ModelOptions' {
import * as Index from '~iridium/dist/lib/Index';
/**
 * Options which can be used to control the way in which a query is executed
 * against the MongoDB database.
 */
export interface QueryOptions {
    cache?: boolean;
    fields?: {
        [name: string]: number;
    };
    limit?: number;
    skip?: number;
    sort?: Index.IndexSpecification;
}
/**
 * Options which can be used to control the way in which a document is created
 * on the MongoDB server.
 */
export interface CreateOptions {
    /**
     * The write concern, can either be a number from 0 to the number of nodes within
     * the cluster, or "majority" if you would like to wait for the majority of nodes
     * within the cluster to confirm the write before returning.
     *
     * It is recommended that you set this to "majority", however in all situations
     * where you mind if data is lost, you should set it to at least 1.
     */
    w?: string | number;
    /**
     * The timeout in milliseconds before the write will be aborted by the MongoDB server
     * and an error response (if the write concern is non-zero) is returned to the client.
     */
    wtimeout?: number;
    /**
     * Whether to wait for the write to be commited to the server's journal (flushed to disk)
     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:"majority"
     * to give excellent write reliability within a cluster, even across failures.
     */
    j?: number;
    /**
     * Whether or not to serialize JavaScript functions which are provided as values. For security
     * reasons it is probably best to set this to false, however it may come in handy under certain
     * circumstances.
     */
    serializeFunctions?: boolean;
    /**
     * Whether to generate document ObjectIDs within the client library or on the server, it is recommended
     * that you leave this to default (false) unless you are making thousands of inserts per second from
     * a single node and experiencing _id collisions.
     */
    forceServerObjectId?: boolean;
    /**
     * Whether to perform an upsert operation if the document already exists.
     */
    upsert?: boolean;
    /**
     * Whether to store the resulting document in the Iridium document cache to boost later retrieval times.
     */
    cache?: boolean;
}
export interface UpdateOptions {
    /**
     * The write concern, can either be a number from 0 to the number of nodes within
     * the cluster, or "majority" if you would like to wait for the majority of nodes
     * within the cluster to confirm the write before returning.
     *
     * It is recommended that you set this to "majority", however in all situations
     * where you mind if data is lost, you should set it to at least 1.
     */
    w?: string | number;
    /**
     * The timeout in milliseconds before the write will be aborted by the MongoDB server
     * and an error response (if the write concern is non-zero) is returned to the client.
     */
    wtimeout?: number;
    /**
     * Whether to wait for the write to be commited to the server's journal (flushed to disk)
     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:"majority"
     * to give excellent write reliability within a cluster, even across failures.
     */
    j?: boolean;
    /**
     * Whether to perform an upsert operation if the document already exists. This can be combined
     * with $setOnInsert to automatically create documents which do not exist in the database prior
     * to making changes - and can be very handy for high-throughput systems.
     */
    upsert?: boolean;
    /**
     * Whether to update multiple documents at once, defaults to false unless run using a method
     * which explcitly sets it to true.
     */
    multi?: boolean;
}
export interface RemoveOptions {
    /**
     * The write concern, can either be a number from 0 to the number of nodes within
     * the cluster, or "majority" if you would like to wait for the majority of nodes
     * within the cluster to confirm the write before returning.
     *
     * It is recommended that you set this to "majority", however in all situations
     * where you mind if data is lost, you should set it to at least 1.
     */
    w?: string | number;
    /**
     * The timeout in milliseconds before the write will be aborted by the MongoDB server
     * and an error response (if the write concern is non-zero) is returned to the client.
     */
    wtimeout?: number;
    /**
     * Whether to wait for the write to be commited to the server's journal (flushed to disk)
     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:"majority"
     * to give excellent write reliability within a cluster, even across failures.
     */
    j?: boolean;
    /**
     * Whether to only remove the first document in the collection or not, by default this is false
     * and any document matching the conditions will be removed.
     */
    single?: boolean;
}
}
declare module 'iridium/dist/lib/ModelOptions' {
export * from '~iridium/dist/lib/ModelOptions';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Configuration.d.ts
declare module '~iridium/dist/lib/Configuration' {
export interface Configuration {
    host?: string;
    port?: number;
    hosts?: {
        address: string;
        port?: number;
    }[];
    database?: string;
    username?: string;
    password?: string;
    options?: ConnectionOptions;
    [key: string]: any;
}
export interface ConnectionOptions {
    db?: DatabaseLevelConnectionOptions;
    server?: ServerLevelConnectionOptions;
    replset?: ReplicasetLevelConnectionOptions;
    mongos?: MongosLevelConnectionOptions;
}
export interface DatabaseLevelConnectionOptions {
    /**
     * The write concern for the operation where < 1 is no acknowledgment of write and w >= 1 or w = ‘majority’ acknowledges the write
     */
    w?: string | number;
    /**
     * Set the timeout for waiting for write concern to finish (combines with w option)
     */
    wtimeout?: number;
    /**
     * Write waits for fsync before returning
     */
    fsync?: boolean;
    /**
     * Write waits for journal sync before returning
     */
    j?: boolean;
    /**
     * The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
     */
    readPreference?: string;
    /**
     * The tags object {‘loc’:‘ny’} used with the readPreference.
     */
    readPreferenceTags?: any;
    /**
     * Use c++ bson parser.
     */
    native_parser?: boolean;
    /**
     * Force server to create _id fields instead of client.
     */
    forceServerObjectId?: boolean;
    /**
     * Object overriding the basic ObjectID primary key generation.
     */
    pkFactory?: any;
    /**
     * Serialize functions.
     */
    serializeFunctions?: boolean;
    /**
     * Perform operations using raw bson buffers.
     */
    raw?: boolean;
    /**
     * Number of milliseconds between retries.
     */
    retryMiliseconds?: number;
    /**
     * Number of retries off connection.
     */
    numberOfRetries?: number;
    /**
     * Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
     */
    bufferMaxEntries?: number;
}
export interface ServerLevelConnectionOptions extends BasicConnectionOptions {
    autoReconnect?: boolean;
}
export interface ReplicasetLevelConnectionOptions extends MongosLevelConnectionOptions {
    replicaSet?: string;
    connectWithNoPrimary?: boolean;
}
export interface MongosLevelConnectionOptions extends BasicConnectionOptions {
    ha?: boolean;
    haInterval?: number;
    secondaryAcceptableLatencyMS?: number;
}
export interface BasicConnectionOptions {
    poolSize?: number;
    ssl?: boolean;
    sslValidate?: boolean;
    sslCA?: Buffer[] | string[];
    sslCert?: Buffer | string;
    sslKey?: Buffer | string;
    sslPass?: Buffer | string;
    socketOptions?: {
        noDelay?: boolean;
        keepAlive?: number;
        connectTimeoutMS?: number;
        socketTimeoutMS?: number;
    };
}
}
declare module 'iridium/dist/lib/Configuration' {
export * from '~iridium/dist/lib/Configuration';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Hooks.d.ts
declare module '~iridium/dist/lib/Hooks' {
export interface Hooks<TDocument, TInstance> {
    onCreating?(document: TDocument): Promise<any> | void;
    onRetrieved?(document: TDocument): Promise<any> | void;
    onReady?(instance: TInstance): Promise<any> | void;
    onSaving?(instance: TInstance, changes: any): Promise<any> | void;
}
}
declare module 'iridium/dist/lib/Hooks' {
export * from '~iridium/dist/lib/Hooks';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/BSON.d.ts
declare module '~iridium/dist/lib/BSON' {
export { ObjectID, Binary } from '~iridium~mongodb';
}
declare module 'iridium/dist/lib/BSON' {
export * from '~iridium/dist/lib/BSON';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/Transforms.d.ts
declare module '~iridium/dist/lib/Transforms' {
import { ObjectID, Binary } from '~iridium/dist/lib/BSON';
import { Model } from '~iridium/dist/lib/Model';
export interface Transforms {
    /**
     * A transform which is applied to the entire document.
     */
    $document?: PropertyTransform<any>;
    _id?: PropertyTransform<any>;
    [property: string]: PropertyTransform<any>;
}
/**
 * Converts the value of a property to and from its database representation.
 */
export interface PropertyTransform<T> {
    /**
     * Converts a property's value from its database representation into one
     * suitable for the application.
     * @param value The value stored in the MongoDB database document.
     * @param property The name of the document property to which this transform is being applied.
     * @param model The Iridium Model on which this transform is being applied
     * @returns A derived value which is more useful to the application.
     */
    fromDB(value: T, property: string, model: Model<any, any>): any;
    /**
     * Converts a property's value into a representation more suitable for
     * the database.
     * @param value The value used by the application.
     * @param property The name of the document property to which this transform is being applied.
     * @param model The Iridium Model on which this transform is being applied
     * @returns The database optimized representation of the value.
     */
    toDB(value: any, property: string, model: Model<any, any>): T;
}
export const DefaultTransforms: {
    ObjectID: PropertyTransform<ObjectID>;
    Binary: PropertyTransform<Binary>;
};
}
declare module 'iridium/dist/lib/Transforms' {
export * from '~iridium/dist/lib/Transforms';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/caches/MemoryCache.d.ts
declare module '~iridium/dist/lib/caches/MemoryCache' {
import * as Bluebird from '~iridium~bluebird';
import { Cache } from '~iridium/dist/lib/Cache';
/**
 * A cache implementation which stores documents in an in-memory cache.
 *
 * Be aware that this is an incredibly simplistic implementation which doesn't manage
 * memory usage at all and is very likely NOT suitable for production use.
 */
export class MemoryCache implements Cache {
    private cache;
    set<T>(key: string, value: T): Bluebird<T>;
    get<T>(key: string): Bluebird<T>;
    clear(key: string): Bluebird<boolean>;
}
}
declare module 'iridium/dist/lib/caches/MemoryCache' {
export * from '~iridium/dist/lib/caches/MemoryCache';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/caches/NoOpCache.d.ts
declare module '~iridium/dist/lib/caches/NoOpCache' {
import { Cache } from '~iridium/dist/lib/Cache';
import Bluebird = require('~iridium~bluebird');
/**
 * A cache implementation which does not cache any received documents
 * and returns nothing when requested - mimicking an empty cache.
 *
 * This is the default cache used if one is not supplied and should
 * not impose any significant performance overhead.
 */
export class NoOpCache implements Cache {
    set<T>(key: string, object: T): Bluebird<T>;
    get<T>(key: string): Bluebird<void>;
    clear(key: string): Bluebird<boolean>;
}
}
declare module 'iridium/dist/lib/caches/NoOpCache' {
export * from '~iridium/dist/lib/caches/NoOpCache';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/cacheControllers/IDDirector.d.ts
declare module '~iridium/dist/lib/cacheControllers/IDDirector' {
import { CacheDirector } from '~iridium/dist/lib/CacheDirector';
/**
 * Caches documents using their _id field as the unique cache key. This
 * is useful if you primarily query your documents using their _id field,
 * however can be suboptimal (or even a complete waste) if you use different
 * types of queries.
 */
export class CacheOnID implements CacheDirector {
    valid(object: {
        _id: any;
    }): boolean;
    buildKey(object: {
        _id: any;
    }): any;
    validQuery(conditions: any): boolean;
    buildQueryKey(conditions: any): any;
}
}
declare module 'iridium/dist/lib/cacheControllers/IDDirector' {
export * from '~iridium/dist/lib/cacheControllers/IDDirector';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/lib/utils/ObjectID.d.ts
declare module '~iridium/dist/lib/utils/ObjectID' {
import * as MongoDB from '~iridium~mongodb';
/**
 * Converts a string to an ObjectID instance - a shortcut for require("mongodb").ObjectID.createFromHexString
 *
 * @param value The string representation of the ObjectID you wish to create.
 * @returns A MongoDB ObjectID instance equivalent to the string you provided.
 *
 * You should be aware that this method performs no validation on the received string, MongoDB's ObjectID requires
 * that it either be a 12 byte UTF8 string, or a 24 byte hexadecimal string in order to be converted correctly.
 *
 * This method removes the need for your application to directly depend on MongoDB's Node.js client library,
 * which helps clean up your code a bit and reduces the headache of maintaining two different versions of the
 * library (since Iridium also has one).
 */
export function toObjectID(value: string): MongoDB.ObjectID;
}
declare module 'iridium/dist/lib/utils/ObjectID' {
export * from '~iridium/dist/lib/utils/ObjectID';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sierrasoftworks/iridium/7.0.0-dev/dist/iridium.d.ts
declare module '~iridium/dist/iridium' {
export * from '~iridium/dist/lib/Core';
export * from '~iridium/dist/lib/Model';
export * from '~iridium/dist/lib/Instance';
export * from '~iridium/dist/lib/Decorators';
export * from '~iridium/dist/lib/Plugins';
export * from '~iridium/dist/lib/Schema';
export * from '~iridium/dist/lib/Cache';
export * from '~iridium/dist/lib/CacheDirector';
export * from '~iridium/dist/lib/ModelOptions';
export * from '~iridium/dist/lib/Configuration';
export * from '~iridium/dist/lib/Hooks';
export * from '~iridium/dist/lib/Transforms';
export * from '~iridium/dist/lib/caches/MemoryCache';
export * from '~iridium/dist/lib/caches/NoOpCache';
export * from '~iridium/dist/lib/cacheControllers/IDDirector';
export * from '~iridium/dist/lib/utils/ObjectID';
}
declare module 'iridium/dist/iridium' {
export * from '~iridium/dist/iridium';
}
declare module 'iridium' {
export * from '~iridium/dist/iridium';
}
